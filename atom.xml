<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GDDA</title>
  
  <subtitle>GameDesignDreamAchieve</subtitle>
  <link href="http://quruipeng666.github.io/atom.xml" rel="self"/>
  
  <link href="http://quruipeng666.github.io/"/>
  <updated>2024-06-25T14:53:59.148Z</updated>
  <id>http://quruipeng666.github.io/</id>
  
  <author>
    <name>GDQLF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>6-25做题笔记2</title>
    <link href="http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/"/>
    <id>http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/</id>
    <published>2024-06-25T14:29:15.000Z</published>
    <updated>2024-06-25T14:53:59.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这次的题目有些经典"><a href="#这次的题目有些经典" class="headerlink" title="这次的题目有些经典"></a>这次的题目有些经典</h2><h3 id="若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1-n-全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）"><a href="#若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1-n-全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）" class="headerlink" title="若数组S[1..n]作为两个栈S1和S2的存储空间，对任何一个栈，只有当[1..n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）"></a>若数组S[1..n]作为两个栈S1和S2的存储空间，对任何一个栈，只有当[1..n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）</h3><p>S1的栈底位置为1，S2的栈底位置为n</p><p>重点：注意数组下标从1开始，栈S1的栈底位置在1，随着元素入栈，朝数组索引增加方向增加。栈S2的栈底位置在n，随元素入栈，朝数组索引减少方向增加。按照这样的方案，只有当数组S全满时才不能进行进栈操作，此时两个栈的指针设想均在数组索引最中间位置。</p><h3 id="假设有60行70列的二维数组-a-1-…60-1…70-以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素-a-32-58-的存储地址为"><a href="#假设有60行70列的二维数组-a-1-…60-1…70-以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素-a-32-58-的存储地址为" class="headerlink" title="假设有60行70列的二维数组 a[1 …60, 1…70 ] 以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素 a[ 32,58 ] 的存储地址为"></a>假设有60行70列的二维数组 a[1 …60, 1…70 ] 以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素 a[ 32,58 ] 的存储地址为</h3><p>注意：题目是说按列存储，不是按行存储！！存储第32行第58列元素之前，一共存储的元素个数为：57<em>60+31&#x3D;3451，需要的存储单元数为3451</em>2&#x3D;6902，又因为基地址为10000，故存储完第31行第58列元素位置为16901，所以存储第32行第58列元素地址为16902（开始）。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;这次的题目有些经典&quot;&gt;&lt;a href=&quot;#这次的题目有些经典&quot; class=&quot;headerlink&quot; title=&quot;这次的题目有些经典&quot;&gt;&lt;/a&gt;这次的题目有些经典&lt;/h2&gt;&lt;h3 id=&quot;若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6.25做题笔记1</title>
    <link href="http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/"/>
    <id>http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/</id>
    <published>2024-06-25T13:38:43.000Z</published>
    <updated>2024-06-25T13:56:53.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录"><a href="#大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录" class="headerlink" title="大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录"></a>大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录</h2><h3 id="在一个长度为n的顺序表中删除第i个元素，要移动-个元素。如果要在第i个元素前插入一个元素，要后移-个元素。"><a href="#在一个长度为n的顺序表中删除第i个元素，要移动-个元素。如果要在第i个元素前插入一个元素，要后移-个元素。" class="headerlink" title="在一个长度为n的顺序表中删除第i个元素，要移动_______个元素。如果要在第i个元素前插入一个元素，要后移_________个元素。"></a>在一个长度为n的顺序表中删除第i个元素，要移动_______个元素。如果要在第i个元素前插入一个元素，要后移_________个元素。</h3><p>删除第i个元素，要移动后面   n-i   个元素。在    第i个元素之前    插入，要移动包括    i在内的n-i+1    个元素。</p><p>重点    在第i个之前插，移动要包括那个i元素，则为n-i+1。</p><h3 id="在C-中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是-。"><a href="#在C-中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是-。" class="headerlink" title="在C++中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是( )。"></a>在C++中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是( )。</h3><p>char a1[]&#x3D; “program”;<br>char a2[]&#x3D;{‘p’,’r’,’o’,’g’,’r’,’a’,’m’}</p><p>重点    a1中存储的是字符串，因此在末尾存在字符’\0’。a2中没这个字符，故sizeof(a1)&#x3D;8，sizeof(a2)&#x3D;7，a1存储单元数目多。</p><h3 id="采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？"><a href="#采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？" class="headerlink" title="采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？"></a>采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？</h3><p>重点    不正确。假设2乘2的下三角矩阵，还有123三个元素，只是少了一个元素，没有达到节约一半的空间。</p><h3 id="在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）"><a href="#在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）" class="headerlink" title="在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）"></a>在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）</h3><p>如果数组很大的话应该是行优先快，因为数组在内存中是按行优先存储的，在虚存环境下，如果整个数组没有在内存中的话可以比列优先减少内存换进换出的次数。就算整个数组都在内存中，列优先访问a[i][j]还得计算一次乘法，行优先只需加一就可以了，这个可以忽略</p><p>分析:若在内存中,则数据可以”随机存取”,但内存数据被读取或写入时,所需要的时间与这段信息所在的位置无关.但是在读取和写入磁盘时,其所需要的时间与位置就会有关系.因为在BASIC,PASCAL和C&#x2F;C++语言中,数组的存放是按照行优先来存放的,按行号第一行第二行…以此类推.本体关键是考察内存抖动的问题,如果按列访问则需要跳过一大串内存地址,这样可能需求的内存地址不在当前页中则需要进行页置换,这样便需要硬盘IO,减低速度. </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录&quot;&gt;&lt;a href=&quot;#大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录&quot; class=&quot;headerlink&quot; title=&quot;大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0512-1</title>
    <link href="http://quruipeng666.github.io/2024/05/12/%E7%AC%94%E8%AE%B00512-1/"/>
    <id>http://quruipeng666.github.io/2024/05/12/%E7%AC%94%E8%AE%B00512-1/</id>
    <published>2024-05-12T13:03:46.000Z</published>
    <updated>2024-05-12T13:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现Player基本移动"><a href="#实现Player基本移动" class="headerlink" title="实现Player基本移动"></a>实现Player基本移动</h2><h3 id="添加必要组件"><a href="#添加必要组件" class="headerlink" title="添加必要组件"></a>添加必要组件</h3><p>Box Collider 2D设置碰撞体，设置到脚下很小的一部分碰撞体</p><p>Rigidbody 2D中的Gravity Scale改为0</p><h3 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h3><p>创建Assets–&gt;Scripts–&gt;Player处的文件，添加Player脚本绑定到Player上</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><p>思路：x，y轴的输入存到一个Vector2变量里，给到Rigidbody2D，需要float型的speed，x方向输入，y方向输入这些参数，以及一个Vector2作为移动输入变量</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监测输入函数，在Update中要调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayerInput</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if(inputY == 0)，只能横向，竖向这样走（不允许斜着走）</span></span><br><span class="line">        inputX = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="comment">//if(inputX == 0)</span></span><br><span class="line">        inputY = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//都有输入，斜方向移动</span></span><br><span class="line">        <span class="keyword">if</span>(inputX != <span class="number">0</span> &amp;&amp; inputY != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inputX = inputX * <span class="number">0.6f</span>;</span><br><span class="line">            inputY = inputY * <span class="number">0.6f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走路状态速度</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.LeftShift))</span><br><span class="line">        &#123;</span><br><span class="line">            inputX = inputX * <span class="number">0.5f</span>;</span><br><span class="line">            inputY = inputY * <span class="number">0.5f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        movementInput = <span class="keyword">new</span> Vector2(inputX, inputY);</span><br><span class="line"></span><br><span class="line">        isMoving = movementInput != Vector2.zero;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//移动函数，用到了刚体（物理），要在FixUpdate中调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Movement</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//2D横板通常用AddForce添加力，纵向的俯视角的用下边的MovePosition移动坐标的位置</span></span><br><span class="line"><span class="comment">//方法就是将它现有的坐标+movementInput这个方向性的坐标再乘速度就能实现俯视角移动</span></span><br><span class="line">        rb.MovePosition(rb.position + movementInput * speed * Time.deltaTime);</span><br><span class="line"><span class="comment">//乘Time.deltaTime为了修正在不同设备上的，不同帧数下的统一的运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现Player基本移动&quot;&gt;&lt;a href=&quot;#实现Player基本移动&quot; class=&quot;headerlink&quot; title=&quot;实现Player基本移动&quot;&gt;&lt;/a&gt;实现Player基本移动&lt;/h2&gt;&lt;h3 id=&quot;添加必要组件&quot;&gt;&lt;a href=&quot;#添加必要组件&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0511-3</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-3/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-3/</id>
    <published>2024-05-11T12:21:29.000Z</published>
    <updated>2024-05-11T12:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Player"><a href="#Player" class="headerlink" title="Player"></a>Player</h2><h3 id="创建Player"><a href="#创建Player" class="headerlink" title="创建Player"></a>创建Player</h3><p>创建Player空的父物体，设置Sorting Group，里边可以设置Sorting Layer为Instance（父及子物体看作是一个整体进行渲染），在Hierarchy中出现在下方的物体会遮盖上方物体，子物体从上往下排序：Shadow，Body，Hair，Arm</p><p>Sprite Renderer组件中的Sprite Sort Point图片渲染参考点，希望按照脚底的中心来进行排序，所以选Pivot</p><p>Sorting Layer设置对应的图层（Instance）和序，Order in Layer序号越大渲染表现越能遮盖</p><h3 id="俯视角需做小修改"><a href="#俯视角需做小修改" class="headerlink" title="俯视角需做小修改"></a>俯视角需做小修改</h3><p>随便拖个草丛进场景，在Player上下拖动并没有在上侧去到Player后方，按照Z轴方向渲染，数值越小离摄像机越近，反之越远，所以出现这种叠层关系</p><p>Editor–&gt;Project Settings–&gt;Graphics里的Transparency Sort Mode 改成Custom Axis，Y改1，Z改0</p><h3 id="锚点位置设置在底部中心"><a href="#锚点位置设置在底部中心" class="headerlink" title="锚点位置设置在底部中心"></a>锚点位置设置在底部中心</h3><p>是为了处理俯视角的物体遮罩关系</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//未完待续</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Player&quot;&gt;&lt;a href=&quot;#Player&quot; class=&quot;headerlink&quot; title=&quot;Player&quot;&gt;&lt;/a&gt;Player&lt;/h2&gt;&lt;h3 id=&quot;创建Player&quot;&gt;&lt;a href=&quot;#创建Player&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0511-2</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-2/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-2/</id>
    <published>2024-05-11T09:50:01.000Z</published>
    <updated>2024-05-11T10:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模拟经营项目"><a href="#模拟经营项目" class="headerlink" title="模拟经营项目"></a>模拟经营项目</h2><h3 id="导入素材"><a href="#导入素材" class="headerlink" title="导入素材"></a>导入素材</h3><p>在导入的素材里的Art文件夹里，例如Maps里文件名后加@20，意思是瓦片地图可以被切割的，像素单位是20，也就是一个格子里有20个像素</p><p>另外是正常的图片，还有一种是家具，是多图片构成的图片素材，切割的时候使用自动切割，单独去使用里边的图片</p><h3 id="图片设置方式"><a href="#图片设置方式" class="headerlink" title="图片设置方式"></a>图片设置方式</h3><p>以地图为例，选中它，再将Sprite Mode改成Multiple，也就是多图片构成的，Pixels Per Unit设置为20，Filter Mode改成Point(no filter)</p><p>Compression改成None，这样会适应我们要做的像素游戏。Max Size尽量不要超过2048，我们的图片是640×460，那么1024就足够了，完成后点击Apply</p><p>如何将这种图片设置方式定为预设，直接应用就行了呢？添加预设的方法是右上角问号旁边的设置按钮，点击就是选择一个预设，可以将当前的预制保存下Save，找到个文件夹设置叫Slice20，再多选要设置的图片文件，设置里选Slice20再点Apply</p><h3 id="切割图片成瓦片"><a href="#切割图片成瓦片" class="headerlink" title="切割图片成瓦片"></a>切割图片成瓦片</h3><p>点击Sprite Editor–&gt;Slice，Type选Grid By Cell Size（按照尺寸)，项目是按照20的瓦片，Pixel Size的X,Y都为20，锚点位置Pivot保持在Center（图片中心）就可以了</p><p>下边有个模式Method，里边的Smart会切割并保留我们仅有图片像素的位置，那么空白的位置将不被保留，不像以前即使你没有画任何的像素在空格的位置，它也会切割一个瓦片，性能有很大的提升</p><p>另外Smart后期对当前这个图片做额外的修改，也可以用Smart将新增的图片直接添加进去，不会破坏原有的结构，所以通常来讲都用Smart，点击Slice切割，再点Apply，那么一张图片就切好了，跟预想的一样，空白的位置并没有切割出瓦片</p><p>Player文件夹里是分各个部分的，拿工具，头，手，身体，是按照它们的动画来进行分类的，这么做的目的是可以利用只简单切换手臂并保留身体和头发的动画就实现比如跑步，举着东西跑步两种动画的切换，另外，这样分割的好处就是如果以后修改这套素材，例如人物原始的图片资源素材，如果修改了服装，样式的话，你也可以将它导入这种序列帧的动画，然后实现换装的效果，所以将它都分开了</p><p>首先同样应用在Slice20这个Preset，点击Apply后再点Sprite Editor，我们所有人物的动画都是8帧的，所以切割的时候按照Grid By Cell Count来切，Column&amp;Row分别为8,1,锚点Pivot要选在Bottom,Method选为Smart点击Slice切割</p><p>选中一个图片后，锚点是在脚下，因为俯视角游戏，希望按照y轴来进行渲染，进行图层的排序，这样的话会有很明显的遮挡的效果</p><p>家具图片，在Sprite Editor里Type使用Automatic自动切割，Pivot锚点也是底部Bottom，然后选Smart，再点Slice切割，最后点Apply</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未完待续</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模拟经营项目&quot;&gt;&lt;a href=&quot;#模拟经营项目&quot; class=&quot;headerlink&quot; title=&quot;模拟经营项目&quot;&gt;&lt;/a&gt;模拟经营项目&lt;/h2&gt;&lt;h3 id=&quot;导入素材&quot;&gt;&lt;a href=&quot;#导入素材&quot; class=&quot;headerlink&quot; title=&quot;导</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>模拟经营项目的笔记0511</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E6%A8%A1%E6%8B%9F%E7%BB%8F%E8%90%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AC%94%E8%AE%B00511/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E6%A8%A1%E6%8B%9F%E7%BB%8F%E8%90%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AC%94%E8%AE%B00511/</id>
    <published>2024-05-11T09:08:35.000Z</published>
    <updated>2024-05-11T09:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><p>本项目要求Unity引擎 编辑器版本 至少在2021.2.10f1c1以上，创建项目的时候要选中此编辑器版本才可生效</p><p>会使用到2D(URP)模板，但建议从2D核心模板开始创建项目，这样还可以学习将当前2D项目升级到通用渲染管线URP</p><h3 id="Unity2021-2-新版界面介绍（工具栏使用"><a href="#Unity2021-2-新版界面介绍（工具栏使用" class="headerlink" title="Unity2021.2 新版界面介绍（工具栏使用"></a>Unity2021.2 新版界面介绍（工具栏使用</h3><p>使用2021.2.10f1c1这样相对来说较新的版本，打开后映入眼帘的是工具栏的样式和位置，那些控制移动的图标(快捷键QWERT,可以直接隐藏，选择Scene窗口再按下空格键弹出小窗口，在里边可以选择显示哪些组件功能例如我不希望Tools显示，点击眼睛关掉即可)，原先应该在工具栏最左侧的位置，现在变成了活动可移动的窗口，拖动也可让它重回原先的位置</p><p>其中的一个按钮展开可以选择图片中心点为移动点或图片锚点为移动点，另一按钮展开为全局的移动旋转或局部的移动旋转可供显示切换</p><p>Scene场景打开灯光显示，下拉菜单打开后处理，天空盒，雾，粒子系统等等，Scene场景摄像机，网格的显示</p><p>Search功能可以搜索，例如我可以在场景当中搜索我想要的关键字，例如我调用了哪个Prefab哪个文件</p><h3 id="Package-Manager（包管理"><a href="#Package-Manager（包管理" class="headerlink" title="Package Manager（包管理"></a>Package Manager（包管理</h3><p>Window–&gt;Package Manager，打开窗口后选择Packages:In Project，可以看到当前项目中以及加载好的组件</p><p>2021.2或以上版本会出现Features分类，里边会包括目前已经内置安装好的功能，我们对里边的2D Tilemap Extras插件不陌生，里边包括规则的瓦片，动态的瓦片这些，Unity已经正式推出并包含在2D主题包当中了</p><p>可以看到有很多上箭头，我们可以选择需要的将它升级，选择不需要的将它Remove移除</p><p>没使用Plastic SCM进行版本管理，可以直接将Version Control移除</p><p>没使用可视化编程，将Visual Scripting移除，这样也可以将包体减小，加载代码快一些</p><p>如果用的Visual Studio最新版编写代码，将Visual Studio Editor升到最新，Rider同理</p><p>Timeline，Test Framework都是需要的，直接更新到最新（需要预览版本preview可以点齿轮Advanced Project Settings</p><h3 id="导入素材，小工具："><a href="#导入素材，小工具：" class="headerlink" title="导入素材，小工具："></a>导入素材，小工具：</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">接下篇</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建新项目&quot;&gt;&lt;a href=&quot;#创建新项目&quot; class=&quot;headerlink&quot; title=&quot;创建新项目&quot;&gt;&lt;/a&gt;创建新项目&lt;/h2&gt;&lt;p&gt;本项目要求Unity引擎 编辑器版本 至少在2021.2.10f1c1以上，创建项目的时候要选中此编辑器版本才可生效</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第一章.数据结构绪论一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/03/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/03/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-03-21T08:35:16.000Z</published>
    <updated>2024-03-21T10:08:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h2><p>此为《大话数据结构》书的第一章，数据结构绪论。鄙人正在学习此书中…特此留笔记录</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><h3 id="为什么要学数据结构？"><a href="#为什么要学数据结构？" class="headerlink" title="为什么要学数据结构？"></a>为什么要学数据结构？</h3><p>更好地去感受编程之美</p><h3 id="数据结构研究什么？"><a href="#数据结构研究什么？" class="headerlink" title="数据结构研究什么？"></a>数据结构研究什么？</h3><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科</p><h3 id="程序设计是什么？"><a href="#程序设计是什么？" class="headerlink" title="程序设计是什么？"></a>程序设计是什么？</h3><p>程序设计&#x3D;数据结构+算法</p><h3 id="数据结构能帮助到程序设计，从而解决问题？"><a href="#数据结构能帮助到程序设计，从而解决问题？" class="headerlink" title="数据结构能帮助到程序设计，从而解决问题？"></a>数据结构能帮助到程序设计，从而解决问题？</h3><p>程序设计的实质是对确定的问题选择一种好的结构，加上设计一种好的算法</p><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>所谓”巧妇难为无米之炊”，计算机再强大，也得有“米”下锅才能干活，否则就是板砖。这个“米”就是数据。</p><p>数据，是描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</p><p>数据不仅仅包括整型，实型等数值类型，还包括字符及声音，图像，视频等非数值类型</p><p>数据其实就是符号，符号，必须具备两个前提：1.可以输入到计算机中  2.能被计算机程序处理</p><p>对于整型，实型等数值类型，可以进行数值运算</p><p>对于字符数据类型，就需要进行非数值的处理。而声音，图像，视频等其实是可以通过编码的手段变成字符数据来处理的</p><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p>数据元素，是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录</p><p>在人类中，人是数据元素。畜类中，牛，马，羊，鸡，猪，狗等动物是畜类的数据元素</p><h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><p>一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位</p><p>人这个数据元素，可以有眼，耳，鼻，嘴，手，脚数据项，也可以有姓名，年龄，性别，地址，电话等数据项。具体有哪些数据项，视系统决定。</p><p>数据项是数据的最小单位，但真正讨论电影时，讨论的是电影里的角色这样的数据元素，所以数据元素才是数据结构中建立数据模型的着眼点。</p><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>数据对象，是性质相同的数据元素的集合，是数据的子集</p><p>性质相同怎么理解，人都有姓名，生日，性别等相同的数据项</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>结构，简单理解就是关系，比如分子结构，是说组成分子的原子之间的排列方式。</p><p>严格点说，结构是指各个组成部分相互搭配和排列的方式。</p><p>在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构</p><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><p>为编写一个“好”的程序，必须分析待处理对象的特性及各处理对象之间存在的关系</p><h2 id="按照视点的不同，分为逻辑结构和物理结构"><a href="#按照视点的不同，分为逻辑结构和物理结构" class="headerlink" title="按照视点的不同，分为逻辑结构和物理结构"></a>按照视点的不同，分为逻辑结构和物理结构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构，是指数据对象中数据元素之间的相互关系</p><p>逻辑结构分为四种：</p><p>1.集合结构</p><p>集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。类似数学中的集合</p><p>2.线性结构</p><p>线性结构中的数据元素之间是一对一的关系。</p><hr><p>1-2-3-4-5**<br>**********|**<br>********<strong>6</strong><br>**********|**<br>***<strong>9-8-7</strong></p><hr><p>3.树形结构</p><p>树形结构中的数据元素之间存在一种一对多的层次关系</p><hr><p><em><strong><strong><strong><strong><strong>A</strong></strong></strong></strong></strong></em>**</p><hr><p><em><strong><em><strong>B</strong></em>C</strong></em>D*********</p><hr><p><strong>E****F</strong>G<em><strong><em>H</em>I</strong>J**</em></p><hr><p>4.图形结构</p><p>图形结构的数据元素是多对多的关系</p><p>———————————————————————<br>|      |    1  |    2  |   3  |   4  |   5  |   6  |   7  |   8  |   9     |<br>|——————————————————————|<br>| 1   |        |   √  |   √  |       |       |       |       |       |          |<br>| 2   |    √  |       |       |    √ |   √  |       |      |    √ |          |<br>| 3   |    √  |       |       |       |    √  |  √  |      |        |         |<br>| 4   |        |   √  |       |       |        |       |      |    √ |   √    |<br>| 5   |        |   √  |   √  |       |        |       |  √  |       |   √    |<br>| 6   |        |       |   √  |        |       |       |  √  |       |   √    |<br>| 7   |        |       |        |       |   √  |  √   |      |       |   √    |<br>| 8   |        |   √  |        |   √ |        |       |      |       |    √   |<br>| 9   |        |       |        |   √  |   √  |  √   |  √  |   √ |         |<br>———————————————————————</p><p>我们再用示意图表示数据的逻辑结构时，要注意两点：</p><p>1.将每一个数据元素看作一个结点，用圆圈表示</p><p>2.元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示</p><p>逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>物理结构，也叫存储结构。是指数据的逻辑结构在计算机中的存储形式。</p><p>数据的存储结构应正确地反映数据元素之间的逻辑关系</p><p>数据元素的存储结构形式有两种：顺序存储和链式存储</p><p>1.顺序存储结构</p><p>顺序存储结构，是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</p><p>都按顺序排好，每个占一小段空间。数组就是这样的顺序存储结构。当建立一个9个整型数据的数组时，计算机就在内存中找了空地，按照一个整形所占位置大小乘9，开辟一段连续的空间，第一个数组数据第一个位置，第二个数据第二个位置，顺序依次排</p><p>2.链式存储结构</p><p>面对时常要变化的结构，顺序存储并不科学，因为总有插入，总有离开</p><p>链式存储结构，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的</p><p>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，通过地址就能找到相关联数据元素的位置</p><h2 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h2><p>逻辑结构是面向问题的，物理结构是面向计算机的，其基本目标是将数据及其逻辑关系存储到计算机的内存中</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型，是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</p><p>在C语言中，按照取值的不同，数据类型分为两类：</p><p>1.原子类型：不可以再分解的基本类型，包括整型，实型，字符型</p><p>2.结构类型：由若干个类型组合而成，是可以再分解的。比如，整型数组是由若干整型数据组成的</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象，是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息</p><h3 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象数据类型，是指一个数学模型及定义在该模型上的一组操作</p><p>“抽象”的意义在于数据类型的数学抽象特性</p><p>一个抽象数据类型定义了，一个数据对象，数据对象中各数据元素之间的关系及对数据元素的操作</p><p>事实上，抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p><h3 id="描述抽象数据类型的标准格式"><a href="#描述抽象数据类型的标准格式" class="headerlink" title="描述抽象数据类型的标准格式"></a>描述抽象数据类型的标准格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">操作1</span><br><span class="line">初始条件</span><br><span class="line">操作结果描述</span><br><span class="line">操作2</span><br><span class="line">......</span><br><span class="line">操作n</span><br><span class="line">......</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据，数据对象   有若干个数据元素    有若干个数据项</p><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><p>逻辑结构，分为集合结构，线性结构，树形结构，图形结构</p><p>物理结构，分为顺序存储结构，链式存储结构</p><p>抽象数据类型及其描述方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构绪论&quot;&gt;&lt;a href=&quot;#数据结构绪论&quot; class=&quot;headerlink&quot; title=&quot;数据结构绪论&quot;&gt;&lt;/a&gt;数据结构绪论&lt;/h2&gt;&lt;p&gt;此为《大话数据结构》书的第一章，数据结构绪论。鄙人正在学习此书中…特此留笔记录&lt;/p&gt;
&lt;h3 id=&quot;数据</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实现队列</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2024-03-20T13:47:51.000Z</published>
    <updated>2024-03-20T14:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p>主要使用链表实现。这是简单的实现，其他的Clear,Contains等等方法自己实践</p><h3 id="Unity中用VS编译脚本代码实现"><a href="#Unity中用VS编译脚本代码实现" class="headerlink" title="Unity中用VS编译脚本代码实现"></a>Unity中用VS编译脚本代码实现</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 实现队列 : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义队中元素的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">QueueData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队中元素的值</span></span><br><span class="line"><span class="keyword">public</span> QueueData nextItem;</span><br><span class="line"><span class="comment">//队中元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> topData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，一般作用是让参数传进来给这个定义数据结构的变量赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QueueData</span>(<span class="params">QueueData last, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//上一个进的元素（先出队）的下一个元素是当前新进的元素</span></span><br><span class="line">last.nextItem = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QueueData</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义队首元素</span></span><br><span class="line">QueueData top;</span><br><span class="line"><span class="comment">//当前定义的上一个元素</span></span><br><span class="line">QueueData lastData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队Enqueue方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断当前是第一个入队的元素</span></span><br><span class="line"><span class="keyword">if</span>(top == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队首,更新</span></span><br><span class="line">top = <span class="keyword">new</span> QueueData(data);</span><br><span class="line"><span class="comment">//把队首赋值给当前定义的上一个元素</span></span><br><span class="line">lastData = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是第一个入队的元素，不再是队首元素</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每一次新进的元素都会更新lastData</span></span><br><span class="line">lastData = <span class="keyword">new</span> QueueData(top, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队Dequeue方法，注意没参数，返回object型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Dequeue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队首元素的值，用来出队的</span></span><br><span class="line"><span class="built_in">object</span> rsl = top.topData;</span><br><span class="line"><span class="comment">//入队的地方记录了nextItem，它的下一个item就自然变成了下一个要出的元素，就把它放在队首了</span></span><br><span class="line">top = top.nextItem;</span><br><span class="line"><span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单使用下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义初始化</span></span><br><span class="line">MyQueue mq = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">mq.Enqueue(<span class="number">1</span>);</span><br><span class="line">mq.Enqueue(<span class="number">2</span>);</span><br><span class="line">mq.Enqueue(<span class="number">3</span>);</span><br><span class="line">mq.Enqueue(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队并打印</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//1</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//2</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//3</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;队列的实现&quot;&gt;&lt;a href=&quot;#队列的实现&quot; class=&quot;headerlink&quot; title=&quot;队列的实现&quot;&gt;&lt;/a&gt;队列的实现&lt;/h2&gt;&lt;p&gt;主要使用链表实现。这是简单的实现，其他的Clear,Contains等等方法自己实践&lt;/p&gt;
&lt;h3 id=&quot;Uni</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实现堆栈</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%88/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%88/</id>
    <published>2024-03-20T13:24:12.000Z</published>
    <updated>2024-03-20T13:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆栈的实现"><a href="#堆栈的实现" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h2><h3 id="Unity中用VS编译脚本代码实现"><a href="#Unity中用VS编译脚本代码实现" class="headerlink" title="Unity中用VS编译脚本代码实现"></a>Unity中用VS编译脚本代码实现</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 实现栈 : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义栈中元素的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">StackData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//栈中元素的值</span></span><br><span class="line"><span class="keyword">public</span> StackData nextItem;</span><br><span class="line"><span class="comment">//栈中元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> topData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，一般作用是让参数传进来给这个定义数据结构的变量赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StackData</span>(<span class="params">StackData next, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.nextItem = next;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个栈顶元素</span></span><br><span class="line">StackData top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈Push方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先生成这个栈中元素，栈顶元素的更新</span></span><br><span class="line">top = <span class="keyword">new</span> StackData(top, Data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈Pop方法，注意没参数，返回object型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Pop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//栈顶元素的值</span></span><br><span class="line"><span class="built_in">object</span> rsl = top.topData;</span><br><span class="line">top = top.nextItem;</span><br><span class="line"><span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单使用下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义初始化</span></span><br><span class="line">MyStack ms = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">ms.Push(<span class="number">1</span>);</span><br><span class="line">ms.Push(<span class="number">2</span>);</span><br><span class="line">ms.Push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈并打印</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//3</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//2</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆栈的实现&quot;&gt;&lt;a href=&quot;#堆栈的实现&quot; class=&quot;headerlink&quot; title=&quot;堆栈的实现&quot;&gt;&lt;/a&gt;堆栈的实现&lt;/h2&gt;&lt;h3 id=&quot;Unity中用VS编译脚本代码实现&quot;&gt;&lt;a href=&quot;#Unity中用VS编译脚本代码实现&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>队列的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T13:06:57.000Z</published>
    <updated>2024-03-20T13:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出，后进后出。（队列的队指的是排队，先来的先走，后来的后走）</p><p>需要引用using System.Collections;（object型）<br>需要引用using System.Collections.Generic;（泛型）</p><h3 id="Queue的定义"><a href="#Queue的定义" class="headerlink" title="Queue的定义"></a>Queue的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object型的队列定义及初始化，object型需要装箱拆箱类型转换，会有一定的效率损失</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型队列定义</span></span><br><span class="line">Queue&lt;<span class="built_in">int</span>&gt; queue2 = <span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">//往队列中加元素，入队操作</span></span><br><span class="line">queue.EnQueue(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">queue2.EnQueue(<span class="number">1</span>);</span><br><span class="line">queue2.EnQueue(<span class="number">2</span>);</span><br><span class="line">queue2.EnQueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队首元素先离，队列中排最前边（最先进来的）的那个元素先出了，离队操作，此处1先离开</span></span><br><span class="line"><span class="built_in">int</span> v = queue2.Dequeue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">queue2.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断入参的值v是否在队列中</span></span><br><span class="line">queue2.Contains(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//目前队列有几个元素queue2.Count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> w <span class="keyword">in</span> queue2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印w</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>对象池，ObjectPool，一开始会预先加载一定的对象在队列里，用的时候出队，用完再入队。这样是一个循环使用的状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;先进先出，后进后出。（队列的队指的是排队，先来的先走，后来的后走）&lt;/p&gt;
&lt;p&gt;需要引用using System.Collections;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>堆栈的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%A0%86%E6%A0%88%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%A0%86%E6%A0%88%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T12:47:23.000Z</published>
    <updated>2024-03-20T13:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>一种数据容器，也可以叫对象集合。Stack，先进后出，后进先出的对象集合。跟队列的先进先出，后进后出相反</p><h3 id="Stack的定义"><a href="#Stack的定义" class="headerlink" title="Stack的定义"></a>Stack的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">Stack st1 = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//压进元素，入栈操作，在栈的底部，参数为object型，类型不安全</span></span><br><span class="line">st1.Push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的倒二位，此时在栈的顶部，理解为往杯子里放海绵垫，比如拿出海绵垫时，只能先拿最上面的（后进先出）</span></span><br><span class="line">st1.Push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">st1.Push(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">st1.Push(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出元素，出栈操作，出来类型是object型，强转为初始定义的string型，再用v接收，此处v的值是d</span></span><br><span class="line"><span class="built_in">string</span> v = (<span class="built_in">string</span>)st1.Pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//st1.Count表示目前栈中元素的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到当前在栈顶元素的值，并不出栈，不执行Pop操作</span></span><br><span class="line">v = (<span class="built_in">string</span>)st1.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">st1.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前入参v的值是否存在于当前栈中</span></span><br><span class="line">st1.Contains(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> w <span class="keyword">in</span> st1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印w</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆栈&quot;&gt;&lt;a href=&quot;#堆栈&quot; class=&quot;headerlink&quot; title=&quot;堆栈&quot;&gt;&lt;/a&gt;堆栈&lt;/h2&gt;&lt;p&gt;一种数据容器，也可以叫对象集合。Stack，先进后出，后进先出的对象集合。跟队列的先进先出，后进后出相反&lt;/p&gt;
&lt;h3 id=&quot;Stack</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链表的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T11:55:36.000Z</published>
    <updated>2024-03-20T12:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p> C#里的链表有前驱和后驱，严格上说叫双向链表</p><p>需要引用using System.Collections.Generic;</p><h3 id="双向链表的定义"><a href="#双向链表的定义" class="headerlink" title="双向链表的定义"></a>双向链表的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化定义,也是泛型</span></span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点变量定义,也int型</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟List,数组是不一样的，因为它们在内存中是属于一个连续的存储空间，其实List本质底层也是数组。</span></span><br><span class="line"><span class="comment">//像链表，实际上在内存中是离散的，它的空间并不连续，而是通过两个指针，一个指针指向下一个存储位置的地址，另一个指针指向上一个存储位置的地址，链表的链指的就是指针的意思</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加首节点，值是1，前后节点都没有，整个链表里目前只有一个值</span></span><br><span class="line">node = linList.AddFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点的后边添加，一参数为节点，二参为值</span></span><br><span class="line">linList.AddAfter(node,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点的前边添加，node变成现在最新的首节点</span></span><br><span class="line">node = linList.AddBefore(node,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的长度linList.Count,此处是3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空，linList.Clear();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//linList.First.Value为第一个节点当前存的值</span></span><br><span class="line"><span class="comment">//linList.Last.Value为最后一个节点当前存的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处为首节点的前置节点的值node.Previous.Value，node.Previous已经是null了，.Value就会报错</span></span><br><span class="line"><span class="comment">//此处为首节点的下一节点的值node.Next.Value,所以在实际应用时有可能node是最后一个节点，node.Next需要先判断不是null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加到最后一个节点</span></span><br><span class="line">linList.AddLast();</span><br></pre></td></tr></table></figure><h3 id="链表，List，数组。优缺点"><a href="#链表，List，数组。优缺点" class="headerlink" title="链表，List，数组。优缺点"></a>链表，List，数组。优缺点</h3><p>List，数组都是顺序存储，存储空间是连续的，尤其对于List来说，因为数组是不变长度的，List是预先定义了一个较长的数组，在中间添加或移除之后，它会将整个的数组进行位移，比如把索引位为3的值删除掉了，那么索引位为4，5，6直到最后一个都会往前挪一位，那么这样的操作也是比较有消耗的。<br>但对于链表来说，因为本身的存储空间就是离散的，只靠指针连接，那么当删除或插入的时候，仅仅改变的是指针的指向，效率会高于List和数组。<br>但链表在查找的时候，只能通过Next,Previous,First,Last去找到节点，并不能通过索引直接拿到，查找速度只能靠一个一个遍历，而数组，List都可以通过索引位直接拿，查找时间复杂度是O(1)，而对链表来说是O(n)，链表查找的时候效率比较低</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt; C#里的链表有前驱和后驱，严格上说叫双向链表&lt;/p&gt;
&lt;p&gt;需要引用using System.Collections.Generic;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HashSet的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/19/HashSet%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/19/HashSet%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-19T14:37:25.000Z</published>
    <updated>2024-03-19T15:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>用来存储一个不能重复的，包含着不重复项的无序列表</p><p>需要引用using System.Collections.Generic;</p><h3 id="HashSet的定义"><a href="#HashSet的定义" class="headerlink" title="HashSet的定义"></a>HashSet的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">HashSet&lt;<span class="built_in">int</span>&gt; hs1 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">HashSet&lt;<span class="built_in">int</span>&gt; hs2 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加值到hs1</span></span><br><span class="line">hs1.Add(<span class="number">1</span>);</span><br><span class="line">hs1.Add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//加了两次2，实际上相当于加一次2</span></span><br><span class="line">hs1.Add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//长度hs1.Count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">hs1.Remove();</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含</span></span><br><span class="line">hs1.Contains();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">hs1.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//给hs2添加值</span></span><br><span class="line">hs2.Add(<span class="number">2</span>);</span><br><span class="line">hs2.Add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集，hs1只剩2</span></span><br><span class="line">hs1.IntersectWith(hs2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时打印hs1是类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> v <span class="keyword">in</span> hs1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印v</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">hs1.UnionWith(hs2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集，hs2里有的元素，在hs1里如果有就把它去掉，没有无操作</span></span><br><span class="line">hs1.ExceptWith(hs2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对称差集，把hs1中和hs2中交集的部分去掉，只留下剩下的那个元素，无论hs1调用还是hs2调用，作用都一样</span></span><br><span class="line">hs1.SymmetricExceptWith(hs2);</span><br></pre></td></tr></table></figure><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>它是另外一种容器，主要的作用可以用来帮助我们做刚才的集合的操作，并且我们在使用的时候，如果你的元素是唯一的不重复的，比如排名，是不重复的，对于这样的需求，我们可以考虑是否使用set来帮助我们进行存储，但是我们要知道如果使用List，还可以很方便的使用它的排序。set本身没有排序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashSet&quot;&gt;&lt;a href=&quot;#HashSet&quot; class=&quot;headerlink&quot; title=&quot;HashSet&quot;&gt;&lt;/a&gt;HashSet&lt;/h2&gt;&lt;p&gt;用来存储一个不能重复的，包含着不重复项的无序列表&lt;/p&gt;
&lt;p&gt;需要引用using System.C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity面试题基础</title>
    <link href="http://quruipeng666.github.io/2024/03/17/Unity%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/"/>
    <id>http://quruipeng666.github.io/2024/03/17/Unity%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-17T08:48:42.000Z</published>
    <updated>2024-03-17T09:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unity面试题基础"><a href="#Unity面试题基础" class="headerlink" title="Unity面试题基础"></a>Unity面试题基础</h2><h3 id="四元数的作⽤"><a href="#四元数的作⽤" class="headerlink" title="四元数的作⽤"></a>四元数的作⽤</h3><p>四元数⽤于表示旋转。</p><p>其相对于欧拉⻆的优点:</p><p>1.避免万向锁</p><p>2.只需要⼀个4维的四元数就可以执⾏绕任意过原点的向量的旋转，⽅便快捷，在某些实现下⽐旋转矩阵效率更⾼</p><p>3.可以提供平滑插值</p><p>什么是欧拉⻆:</p><p>⽤⼀句话说，欧拉⻆就是物体绕坐标系三个坐标轴(x,y,z轴）的旋转⻆度</p><p>静态：</p><p>即绕世界坐标系三个轴的旋转，由于物体旋转过程中坐标轴保持静⽌，所以称为静态</p><p>动态：</p><p>即绕物体坐标系三个轴的旋转，由于物体旋转过程中坐标轴随着物体做相同的转动，所以称为动态。 </p><p>物体的任何⼀种旋转都可分解为分别绕三个轴的旋转，但分解⽅式不唯⼀。</p><p>unity 3D欧拉⻆的旋转顺序（⽗⼦关系）是y-x-z。</p><p>unity中最简单的万向锁就是先让X轴旋转90度，z轴旋转和y轴旋转效果是⼀样。</p><h3 id="Unity脚本⽣命周期与执⾏顺序"><a href="#Unity脚本⽣命周期与执⾏顺序" class="headerlink" title="Unity脚本⽣命周期与执⾏顺序"></a>Unity脚本⽣命周期与执⾏顺序</h3><p>格式按照  名称；触发时机；用途（有的不包括此条）</p><p>Awake；脚本实例被创建时调用；用于游戏对象的初始化，注意Awake的执行早于所有脚本的Start函数</p><p>OnEnable；当对象变为可用或激活状态时被调用</p><p>Start；Update函数第一次运行之前调用；用于游戏对象的初始化</p><p>Update；每帧调用一次；用于更新游戏场景和状态</p><p>FixedUpdate；每个固定物理时间间隔调用一次；用于物理状态的更新</p><p>LateUpdate；每帧调用一次（在Update之后调用）；用于更新游戏场景和状态，和相机有关的更新一般放在这里</p><p>OnGUI；渲染和处理OnGUI事件</p><p>OnDisable；当前对象不可用或非激活状态时被调用</p><p>OnDestroy；当前对象被销毁时调用</p><h3 id="理解Unity协程"><a href="#理解Unity协程" class="headerlink" title="理解Unity协程"></a>理解Unity协程</h3><p>协程不是线程。协程的实现原理是迭代器，⽽迭代器的实现原理是状态机。</p><p>unity中协程执⾏过程中，通过 yield return XXX，将程序挂起，去执⾏接下来的内容。在遇到 yield return XXX语句之前，协程⽅法和⼀般的⽅法是相同的，也就是程序在执⾏到 yield return XXX语句之后，接着才会执⾏的是 StartCoroutine()⽅法之后的程序，⾛的还是单线程模式，仅仅是将 yield return XXX语句之后的内容暂时挂起，等到特定的时间才执⾏。</p><p>那么挂起的程序什么时候才执⾏？协同程序主要是Update()⽅法之后，LateUpdate()⽅法之前调⽤的。</p><p>通过设置MonoBehaviour脚本的enabled对协程是没有影响的，但如果gameObject.SetActive(false)则已经启动的协程则完全停⽌了，即使在Inspector把gameObject激活还是没有继续执⾏。也就说协程虽然是在MonoBehvaviour启动的（StartCoroutine），但是协程函数的地位完全是跟MonoBehaviour是⼀个层次的，不受MonoBehaviour的状态影响，但跟MonoBehaviour脚本⼀样受gameObject控制，也应该是和MonoBehaviour脚本⼀样每帧轮询yield 的条件是否满⾜</p><h3 id="Unity的碰撞器-Collider-与触发器-Trigger-区别"><a href="#Unity的碰撞器-Collider-与触发器-Trigger-区别" class="headerlink" title="Unity的碰撞器(Collider)与触发器(Trigger)区别"></a>Unity的碰撞器(Collider)与触发器(Trigger)区别</h3><p>碰撞器（Collider）有碰撞效果，IsTrigger&#x3D;false，可以调⽤OnCollisionEnter&#x2F;Stay&#x2F;Exit函数</p><p>触发器(Trigger)没有碰撞效果，isTrigger&#x3D;true，可以调⽤OnTriggerEnter&#x2F;Stay&#x2F;Exit函数</p><h3 id="物体发⽣碰撞的必要条件"><a href="#物体发⽣碰撞的必要条件" class="headerlink" title="物体发⽣碰撞的必要条件"></a>物体发⽣碰撞的必要条件</h3><p>必须带有collider碰撞器和rigibody刚体属性或者⼈物控制器，其实⼈物控制器就包含了前两者，另外⼀个物体也要必须带有Collider，</p><p>Collider分类：⽹格碰撞器，盒⼦碰撞器，胶囊碰撞器，球型碰撞器，地形碰撞器</p><h3 id="CharacterController与Rigidbody的区别"><a href="#CharacterController与Rigidbody的区别" class="headerlink" title="CharacterController与Rigidbody的区别"></a>CharacterController与Rigidbody的区别</h3><p>Rigidbody具有完全真实物理的特性，⽽CharacterController可以说是受限的的Rigidbody，具有⼀定的物理效果但不是完全真实的</p><h3 id="物体发⽣碰撞时，有⼏个阶段和分别对应的函数"><a href="#物体发⽣碰撞时，有⼏个阶段和分别对应的函数" class="headerlink" title="物体发⽣碰撞时，有⼏个阶段和分别对应的函数"></a>物体发⽣碰撞时，有⼏个阶段和分别对应的函数</h3><p>三个阶段，OnCollisionEnter&#x2F;Stay&#x2F;Exit函数</p><h3 id="物体发⽣碰撞时，⼏种施加压⼒的⽅式"><a href="#物体发⽣碰撞时，⼏种施加压⼒的⽅式" class="headerlink" title="物体发⽣碰撞时，⼏种施加压⼒的⽅式"></a>物体发⽣碰撞时，⼏种施加压⼒的⽅式</h3><p>rigidbody.AddForce&#x2F;AddForceAtPosition,都是rigidbody的成员函数</p><h3 id="Unity3d提供了⼏种光源"><a href="#Unity3d提供了⼏种光源" class="headerlink" title="Unity3d提供了⼏种光源"></a>Unity3d提供了⼏种光源</h3><p>共4种，DirectionalLight、PointLight、SpotLight、AreaLight（⽤于烘焙）</p><h3 id="物理更新⼀般在哪个系统函数⾥"><a href="#物理更新⼀般在哪个系统函数⾥" class="headerlink" title="物理更新⼀般在哪个系统函数⾥"></a>物理更新⼀般在哪个系统函数⾥</h3><p>FixedUpdate,每固定帧绘制时执⾏⼀次，和update不同的是FixedUpdate是渲染帧执⾏，如果你的渲染帧效率低下的时候FixedUpdate调⽤次数就会跟着下降。FixedUpdate⽐较适合⽤于物理引擎的计算，因为是跟每帧的渲染有关。Update就⽐较适合做控制</p><h3 id="移动相机动作在哪个函数⾥，为什么在这个函数⾥"><a href="#移动相机动作在哪个函数⾥，为什么在这个函数⾥" class="headerlink" title="移动相机动作在哪个函数⾥，为什么在这个函数⾥"></a>移动相机动作在哪个函数⾥，为什么在这个函数⾥</h3><p>LateUpdate，是在所有的update结束后才调⽤，⽐较适合⽤于命令脚本的执⾏。官⽹上例⼦是摄像机的跟随，都是所有的update操作完才进⾏摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视⻆⾥还未有⻆⾊的空帧出现</p><h3 id="简述Prefab的⽤处"><a href="#简述Prefab的⽤处" class="headerlink" title="简述Prefab的⽤处"></a>简述Prefab的⽤处</h3><p>在游戏运⾏时实例化，prefab相当于⼀个模板，对你已经有的素材、脚本、参数做⼀个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流</p><h3 id="简述对象池-在FPS游戏⾥哪些东⻄适合使⽤对象池"><a href="#简述对象池-在FPS游戏⾥哪些东⻄适合使⽤对象池" class="headerlink" title="简述对象池,在FPS游戏⾥哪些东⻄适合使⽤对象池"></a>简述对象池,在FPS游戏⾥哪些东⻄适合使⽤对象池</h3><p>对象池就存放需要被反复调⽤资源的⼀个空间，⽐如游戏中要常被⼤量复制的对象，⼦弹，敌⼈，以及任何重复出现的对象</p><h3 id="如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法"><a href="#如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法" class="headerlink" title="如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法"></a>如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法</h3><p>1.将Assets和Library⼀起迁移</p><p>2.导出包package</p><p>3.⽤unity⾃带的assets Server功能</p><h3 id="OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣"><a href="#OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣" class="headerlink" title="OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣"></a>OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣</h3><p>Awake–&gt;OnEnable-&gt;Start，OnEnable在同⼀周期中可以反复地发⽣</p><h3 id="MeshRender中material和sharedmaterial的区别"><a href="#MeshRender中material和sharedmaterial的区别" class="headerlink" title="MeshRender中material和sharedmaterial的区别"></a>MeshRender中material和sharedmaterial的区别</h3><p>修改sharedMaterial将改变所有物体使⽤这个材质的外观，并且也改变储存在⼯程⾥的材质设置</p><p>不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使⽤material替代</p><h3 id="TCP-IP协议栈各个层次及分别的功能"><a href="#TCP-IP协议栈各个层次及分别的功能" class="headerlink" title="TCP&#x2F;IP协议栈各个层次及分别的功能"></a>TCP&#x2F;IP协议栈各个层次及分别的功能</h3><p>⽹络接⼝层：这是协议栈的最低层，对应OSI的物理层和数据链路层，主要完成数据帧的实际发送和接收</p><p>⽹络层：处理分组在⽹络中的活动，例如路由选择和转发等，这⼀层主要包括IP协议、ARP、ICMP协议等</p><p>传输层：主要功能是提供应⽤程序之间的通信，这⼀层主要是TCP&#x2F;UDP协议</p><p>应⽤层：⽤来处理特定的应⽤，针对不同的应⽤提供了不同的协议，例如进⾏⽂件传输时⽤到的FTP协议，发送email⽤到的SMTP等</p><h3 id="Unity提供了⼏种光源"><a href="#Unity提供了⼏种光源" class="headerlink" title="Unity提供了⼏种光源"></a>Unity提供了⼏种光源</h3><p>四种。 平⾏光：Directional Light     点光源：Point Light      聚光灯：Spot Light      区域光源：Area Light</p><h3 id="GPU的⼯作原理"><a href="#GPU的⼯作原理" class="headerlink" title="GPU的⼯作原理"></a>GPU的⼯作原理</h3><p>简⽽⾔之，GPU的图形（处理）流⽔线完成如下的⼯作：（并不⼀定是按照如下顺序）</p><p>1.顶点处理：</p><p>这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建⽴起3D图形的⻣架。在⽀持DX8和DX9规格的GPU中，这些⼯作由硬件实现的Vertex Shader（定点着⾊器）完成</p><p>2.光栅化计算：</p><p>显示器实际显示的图像是由像素组成的，我们需要将上⾯⽣成的图形上的点和线通过⼀定的算法转换到相应的像素点。把⼀个⽮量图形转换为⼀系列像素点的过程就称为光栅化。例如，⼀条数学表示的斜线段，最终被转化成阶梯状的连续像素点</p><p>3.纹理帖图：</p><p>顶点单元⽣成的多边形只构成了3D物体的轮廓，⽽纹理映射（texture mapping）⼯作完成对多变形表⾯的帖图，通俗的说，就是将多边形的表⾯贴上相应的图⽚，从⽽⽣成“真实”的图形。TMU（Texture mapping unit）即是⽤来完成此项⼯作</p><p>4.像素处理：</p><p>这阶段（在对每个像素进⾏光栅化处理期间）GPU完成对像素的计算和处理，从⽽确定每个像素的最终属性。在⽀持DX8和DX9规格的GPU中，这些⼯作由硬件实现的Pixel Shader（像素着⾊器）完成</p><p>5.最终输出：</p><p>由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区</p><p>6.总结：</p><p>GPU的⼯作通俗的来说就是完成3D图形的⽣成，将图形映射到相应的像素点上，对每个像素进⾏计算确定最终颜⾊并完成输出</p><h3 id="什么是渲染管道"><a href="#什么是渲染管道" class="headerlink" title="什么是渲染管道"></a>什么是渲染管道</h3><p>是指在显示器上为了显示出图像⽽经过的⼀系列必要操作。 渲染管道中的很多步骤，都要将⼏何物体从⼀个坐标系中变换到另⼀个坐标系中去</p><p>主要步骤：</p><p>本地坐标-&gt;视图坐标-&gt;背⾯裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Unity面试题基础&quot;&gt;&lt;a href=&quot;#Unity面试题基础&quot; class=&quot;headerlink&quot; title=&quot;Unity面试题基础&quot;&gt;&lt;/a&gt;Unity面试题基础&lt;/h2&gt;&lt;h3 id=&quot;四元数的作⽤&quot;&gt;&lt;a href=&quot;#四元数的作⽤&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>泛型容器一一字典</title>
    <link href="http://quruipeng666.github.io/2024/03/17/%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E4%B8%80%E4%B8%80%E5%AD%97%E5%85%B8/"/>
    <id>http://quruipeng666.github.io/2024/03/17/%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E4%B8%80%E4%B8%80%E5%AD%97%E5%85%B8/</id>
    <published>2024-03-17T08:22:09.000Z</published>
    <updated>2024-03-17T08:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>泛型容器，存储键&#x2F;值对的数据的集合。键&#x2F;值对的类型必须是预先定义好的，类型安全。</p><h3 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a>字典的定义</h3><p>使用字典需要引用using System.Collections.Generic;</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化一个key是string类型，value也是string型的字典</span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; dic1 = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">dic1.Add(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;100&quot;</span>);</span><br><span class="line">dic1.Add(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;200&quot;</span>);</span><br><span class="line">dic1.Add(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;300&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在键</span></span><br><span class="line"><span class="keyword">if</span>(dic1.ContainsKey(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印（存在&quot;1&quot;键）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">dic1[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;1000&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历，另一种取出所有键方式也行</span></span><br><span class="line"><span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; kvp <span class="keyword">in</span> dic1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印每一对 键/值对 的 kvp.Key 和 kvp.Value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">dic1.Remove(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">dic1.Clear();</span><br></pre></td></tr></table></figure><p>字典跟哈希表的使用方式非常像</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>字典定义时需要是泛型，需要指定好类型，这样的话在使用的时候就没有装箱拆箱类型转换那一步，执行效率非常高。<br>哈希表在Add（key，value）时都是object类型的，必须会多了装箱拆箱类型转换这个操作，执行效率会低一些。</p><h3 id="了解概念"><a href="#了解概念" class="headerlink" title="了解概念"></a>了解概念</h3><p>线程安全，线程不安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h2&gt;&lt;p&gt;泛型容器，存储键&amp;#x2F;值对的数据的集合。键&amp;#x2F;值对的类型必须是预先定义好的，类型安全。&lt;/p&gt;
&lt;h3 id=&quot;字典的定义&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>哈希table一一Hashtable</title>
    <link href="http://quruipeng666.github.io/2024/03/17/%E5%93%88%E5%B8%8Ctable%E4%B8%80%E4%B8%80Hashtable/"/>
    <id>http://quruipeng666.github.io/2024/03/17/%E5%93%88%E5%B8%8Ctable%E4%B8%80%E4%B8%80Hashtable/</id>
    <published>2024-03-17T08:02:36.000Z</published>
    <updated>2024-03-17T08:20:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>中文全称叫 哈希表。它是一个集合容器。Hashtable类代表了基于键的哈希代码组织起来的 键&#x2F;值 对 的集合。</p><p>每存储一个元素，都有一个键以及这个键所对应的一个值，也叫键&#x2F;值对，它使用键来访问集合中的元素。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">Hashtable ht1 = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型不安全，key(键)，value(值)都是Object类型。</span></span><br><span class="line">ht1.Add(<span class="string">&quot;1&quot;</span>,<span class="number">100</span>);</span><br><span class="line">ht1.Add(<span class="number">1</span>,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作，ht1.Clear();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ht1.ContainsKey(&quot;1&quot;);判断有没有&quot;1&quot;这个键，如果有返回true，反之false。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ht1.Count有几对键值对，这里是2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除操作，ht1.Remove(&quot;1&quot;);参数是key(键)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如我们想取出字符串&quot;1&quot;键的值，就写ht1[&quot;1&quot;]</span></span><br><span class="line"><span class="comment">//比如我们想取出int型1键的值，就写ht1[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如我们想修改int型1键的值为999，就写ht1[1]=999;如果有int型1键的话才能改，否则会出现异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">ICollection key=ht1.Keys;<span class="comment">//所有键</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> k <span class="keyword">in</span> key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印ht1[k]，每一个值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hashtable&quot;&gt;&lt;a href=&quot;#Hashtable&quot; class=&quot;headerlink&quot; title=&quot;Hashtable&quot;&gt;&lt;/a&gt;Hashtable&lt;/h2&gt;&lt;p&gt;中文全称叫 哈希表。它是一个集合容器。Hashtable类代表了基于键的哈希代码组织</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>泛型类集合一一List</title>
    <link href="http://quruipeng666.github.io/2024/03/17/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E9%9B%86%E5%90%88%E4%B8%80%E4%B8%80List/"/>
    <id>http://quruipeng666.github.io/2024/03/17/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E9%9B%86%E5%90%88%E4%B8%80%E4%B8%80List/</id>
    <published>2024-03-17T06:49:06.000Z</published>
    <updated>2024-03-17T07:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>也是一种容器，泛型类集合。对于List来说，往往会和泛型配合使用，List&lt;&gt;。</p><p>功能和作用类似于 ArrayList。List比ArrayList出现得晚一些，是具有更好的功能。</p><p>ArrayList不是指定固定类型的，实际上它的参数是Object类型，也就是说不管我们使用的是int，string还是我们定义的一个类，拿它作为ArrayList的参数的时候，都必须要通过一个装箱和拆箱的操作，同时还要再完成类型转换。</p><p>装箱，拆箱，类型转换是有一定的性能消耗，如果我们使用List，由于它是一个泛型，用的时候必须要指定某一种具体类型，那么它就无需装箱，拆箱，类型转换。</p><p>由此它类型安全，不会出现不同类型之间所产生的一些异常的问题。</p><h3 id="声明List"><a href="#声明List" class="headerlink" title="声明List"></a>声明List</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//List定义的&lt;int&gt;，只能添加int型元素，类型安全。ArrayList类型不安全。</span></span><br><span class="line">list1.Add(<span class="number">1</span>);</span><br><span class="line">list1.Add(<span class="number">2</span>);</span><br><span class="line">list1.Add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//list1.Count长度为3</span></span><br><span class="line"><span class="comment">//list1.Clear();  list1.Contains();  list1.Insert();  list1.InsertRange();  list1.Remove();</span></span><br><span class="line"><span class="comment">//通过for循环，foreach也能进行遍历</span></span><br><span class="line"><span class="comment">//list1.Sort();  list1.Reverse();  list1.IndexOf();</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h2&gt;&lt;p&gt;也是一种容器，泛型类集合。对于List来说，往往会和泛型配合使用，List&amp;lt;&amp;gt;。&lt;/p&gt;
&lt;p&gt;功能和作用类似于</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>arraylist的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/15/arraylist%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/15/arraylist%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-15T15:14:13.000Z</published>
    <updated>2024-03-15T15:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="arraylist"><a href="#arraylist" class="headerlink" title="arraylist"></a>arraylist</h2><p>一种新的容器，动态数组，关于 ※对象的有序集合※ 。跟数组的作用很接近，都是用来存储对象的，而且都是一个有序的集合。</p><p>数组是固定的长度，对于动态数组来说，就解决了数组只能固定长度的缺点，动态数组有自己的一个 ※自动重新调整大小※ 的能力。</p><p>同时，我们也 ※可以通过这个索引位在动态数组里面去插入，删除等的操作※ 。数组不能够，数组的位置是固定的，我们只能取或改数组，但是不能够在数组中间随意地去插入或者删除新的元素。</p><p>所以我们就知道了动态数组跟数组最大的一个区别。</p><p>在使用方面呢，跟数组的这个形式实际上是很像的。</p><h3 id="动态数组的定义"><a href="#动态数组的定义" class="headerlink" title="动态数组的定义"></a>动态数组的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对动态数组初始化的定义</span></span><br><span class="line">ArrayList arraylist1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">arraylist1.Add(<span class="number">45</span>);</span><br><span class="line">arraylist1.Add(<span class="number">25</span>);</span><br><span class="line">arraylist1.Add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//arraylist1[0]就是第一个值，45。依此类推，arraylist1[1]是25，arraylist1[2]是12。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="built_in">int</span>[] array1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">arraylist1.AddRange(array1);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> v <span class="keyword">in</span> arraylist1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印v，结果分别是45，25，12，1，2，3，4。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空，删除全部值</span></span><br><span class="line">arraylist1.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//用arraylist1.Contains(12)可以判断arraylist1里是否包含12这个值，如果包含返回true，反之false。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOf()方法返回参数第一次出现的下标值，没找到返回-1</span></span><br><span class="line">ArrayList arraylist2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="built_in">int</span>[] array2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">7</span>] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">12</span>&#125;;</span><br><span class="line">arraylist2.IndexOf(<span class="number">12</span>);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Insert()插入方法,第一参数你从什么索引开始插入，第二参数你要插入什么元素。第一参数索引位得存在，不存在会报错。</span></span><br><span class="line">arraylist2.Insert(<span class="number">3</span>,<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Remove()删除方法，参数就是元素的值，会删除第一次出现的匹配值，如果没有匹配值，相当于没起作用。</span></span><br><span class="line">arraylist2.Remove(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arraylist2[100] = 12;无法执行，100这个索引没被分配，索引引用不到，产生错误。如果这样写一定保证有那么多元素，如果不够的话只能使用Add的方式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Reverse()逆转顺序方法</span></span><br><span class="line">arraylist2.Reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sort()排序方法，对于这种数值型的元素，是可以进行排序的。从小到大排序。</span></span><br><span class="line">arraylist2.Sort();</span><br></pre></td></tr></table></figure><h3 id="方法的重载，依据方法传入参数的数量或类型不同，调用的不同功能实现的同名方法"><a href="#方法的重载，依据方法传入参数的数量或类型不同，调用的不同功能实现的同名方法" class="headerlink" title="方法的重载，依据方法传入参数的数量或类型不同，调用的不同功能实现的同名方法"></a>方法的重载，依据方法传入参数的数量或类型不同，调用的不同功能实现的同名方法</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;arraylist&quot;&gt;&lt;a href=&quot;#arraylist&quot; class=&quot;headerlink&quot; title=&quot;arraylist&quot;&gt;&lt;/a&gt;arraylist&lt;/h2&gt;&lt;p&gt;一种新的容器，动态数组，关于 ※对象的有序集合※ 。跟数组的作用很接近，都是用来存储</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/15/%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/15/%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-15T09:16:13.000Z</published>
    <updated>2024-03-15T09:18:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>是用来存储数据的集合。数组是要指定长度的。</p><h3 id="数组的特性："><a href="#数组的特性：" class="headerlink" title="数组的特性："></a>数组的特性：</h3><p>1.元素类型相同</p><p>2.固定长度</p><p>3.顺序存储的集合</p><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义int类型的数组</span></span><br><span class="line"><span class="built_in">int</span>[] array1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接定义初始化存储</span></span><br><span class="line"><span class="built_in">int</span>[] array2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接写值，array3长度是5并且长度不能变</span></span><br><span class="line"><span class="built_in">int</span>[] array3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代表当前这个int型数组只能存储3个int型的变量,默认值是0</span></span><br><span class="line">array1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//array1的第一个值就是array1[0]</span></span><br><span class="line">array1[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array1只给分配了三个空间，array1[3]是第四个值，拿不到的，如果这样写在编译期间不会报错，在运行期间会产生一个数组越界的错误。</span></span><br><span class="line"><span class="comment">//array1.Length的值就是3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;array3.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印array3[i]的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用foreach遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> v <span class="keyword">in</span> array2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印v的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;是用来存储数据的集合。数组是要指定长度的。&lt;/p&gt;
&lt;h3 id=&quot;数组的特性：&quot;&gt;&lt;a href=&quot;#数组的特性：&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>每日一刷一一Csharp面试题</title>
    <link href="http://quruipeng666.github.io/2024/03/14/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B7%E4%B8%80%E4%B8%80Csharp%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://quruipeng666.github.io/2024/03/14/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%88%B7%E4%B8%80%E4%B8%80Csharp%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2024-03-14T14:03:00.000Z</published>
    <updated>2024-03-14T14:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-面试题两道"><a href="#C-面试题两道" class="headerlink" title="C#面试题两道"></a>C#面试题两道</h2><h3 id="值类型和引用类型有什么区别？"><a href="#值类型和引用类型有什么区别？" class="headerlink" title="值类型和引用类型有什么区别？"></a>值类型和引用类型有什么区别？</h3><p>值类型：包含了所有简单类型（整数、浮点、bool、char）、struct、enum。</p><p>继承自System.ValueType</p><p>引用类型：包含了string，object，class，interface，delegate，array</p><p>继承自System.Object</p><p>1.值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的是堆中存放的地址。</p><p>2.值类型存取快，引用类型存取慢。</p><p>3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。</p><p>4.栈的内存是自动释放的，堆内存是.NET 中会由 GC 来自动释放。</p><p>5.值类型继承自 System.ValueType,引用类型继承自 System.Object。</p><p>6.值类型直接存放实际的数据，⽽引⽤类型存放的则是数据的地址，即对象的引⽤。</p><p>7.值类型变量直接把变量的值保存在堆栈中，引⽤类型的变量把实际数据的地址保存在堆栈中。</p><h3 id="什么是匿名方法？"><a href="#什么是匿名方法？" class="headerlink" title="什么是匿名方法？"></a>什么是匿名方法？</h3><p>匿名⽅法是⽤作委托的参数的⼀段代码。</p><p>举例子</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名方法，例1</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; anon = <span class="built_in">delegate</span>(<span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//输出2</span></span><br><span class="line">Console.WriteLine(anon(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//匿名方法，例2</span></span><br><span class="line">Action&lt;<span class="built_in">int</span>&gt; anon2 = <span class="built_in">delegate</span>(<span class="built_in">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//输出2</span></span><br><span class="line">Console.WriteLine(anon(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-面试题两道&quot;&gt;&lt;a href=&quot;#C-面试题两道&quot; class=&quot;headerlink&quot; title=&quot;C#面试题两道&quot;&gt;&lt;/a&gt;C#面试题两道&lt;/h2&gt;&lt;h3 id=&quot;值类型和引用类型有什么区别？&quot;&gt;&lt;a href=&quot;#值类型和引用类型有什么区别？&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
