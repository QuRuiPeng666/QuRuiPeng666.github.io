<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GDDA</title>
  
  <subtitle>GameDesignDreamAchieve</subtitle>
  <link href="http://quruipeng666.github.io/atom.xml" rel="self"/>
  
  <link href="http://quruipeng666.github.io/"/>
  <updated>2024-06-29T14:30:54.544Z</updated>
  <id>http://quruipeng666.github.io/</id>
  
  <author>
    <name>GDQLF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第三章-线性表——《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/06/28/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/06/28/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-06-28T07:10:50.000Z</published>
    <updated>2024-06-29T14:30:54.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>为《大话数据结构》书的第三章，线性表。线性表：零个或多个数据元素的有限序列。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>若将线性表记为（a1，…，ai-1，ai，ai+1，…，an），则表中ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i&#x3D;1，2，…，n-1时，ai有且仅有一个直接后继，当i&#x3D;2，3，…，n时，ai有且仅有一个直接前驱。</p><p>a1——a2——…——ai-1——ai——ai+1——…——an</p><p>线性表元素个数n可以为0，称为空表。</p><h3 id="线性表的抽象数据类型定义"><a href="#线性表的抽象数据类型定义" class="headerlink" title="线性表的抽象数据类型定义"></a>线性表的抽象数据类型定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ADT 线性表（List）</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">线性表的数据对象集合为&#123;a1，a2，...，an&#125;，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">InitList（*L）：初始化操作，建立一个空的线性表L。</span><br><span class="line">ListEmpty（L）：若线性表为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">ClearList（*L）：将线性表清空。</span><br><span class="line">GetElem（L，i，*e）：将线性表L中的第i个位置元素值返回给e。</span><br><span class="line">LocateElem（L，e）：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回<span class="number">0</span>表示失败。</span><br><span class="line">ListInsert（*L，i，e）：在线性表L中的第i个位置插入新元素e。</span><br><span class="line">ListDelete（*L，i，*e）：删除线性表L中第i个位置元素，并用e返回其值。</span><br><span class="line">ListLength（L）：返回线性表L的元素个数。</span><br><span class="line">endADT</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><p>顺序存储结构需要三个属性：1.存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。2.线性表的最大存储容量：数组长度MaxSize。3.线性表的当前长度：length。</p><h3 id="数组长度与线性表长度区别"><a href="#数组长度与线性表长度区别" class="headerlink" title="数组长度与线性表长度区别"></a>数组长度与线性表长度区别</h3><p>在任意时刻，线性表的长度Length应该小于等于数组的长度MaxSize。</p><h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。</p><p>假设每个数据元素占用c个存储单元空间，那么线性表中的第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。</p><p>LOC（ai+1）&#x3D;LOC（ai）+c</p><p>LOC（ai）&#x3D;LOC（a1）+（i-1）乘c</p><p>通过这个公式，可以随时算出线性表中任意位置的地址，不管是第一个还是最后一个，都是相同时间。那么对每个线性表位置的存取数据，对于计算机来说都是相等时间，也就是一个常数，存取时间性能为O（1）。通常把具有这一特点的存储结构称为随机存取结构。</p><h3 id="线性表链式存储结构"><a href="#线性表链式存储结构" class="headerlink" title="线性表链式存储结构"></a>线性表链式存储结构</h3><p>头结点的数据域一般存储链表的长度，头结点的指针域存储指向第一个结点的指针，最后一个结点的指针指向空。</p><p>头指针就是链表指向第一个结点的指针，具有标识作用，常用它冠以链表的名字。</p><p>无论链表是否为空，头指针均不为空（空链表时，头指针指向一个双域全空的结点）。头指针是链表的必要元素。头结点不一定是链表必须要素。</p><p>若线性表为空表，则头结点的指针域为空，表示空链表。</p><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>在p与p—&gt;next之间插入s：s—&gt;next &#x3D; p—&gt;next；p—&gt;next &#x3D; s；</p><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p>在p后删除q：q &#x3D; p—&gt;next；p—&gt;next &#x3D; q—&gt;next；</p><p>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。如希望从第i个位置，插入10个元素。</p><h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p>存储分配方式上，顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。</p><p>时间性能上，查找：顺序存储结构O（1）。单链表O（n）。插入和删除：顺序存储结构需要平均移动表长一半的元素，时间为O（n）。单链表在找出某位置的指针后，插入和删除时间仅为O（1）。</p><p>空间性能上，顺序存储结构需要预分配存储空间，分大了浪费，分小了易发生上溢。单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。</p><h3 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h3><p>优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p><p>缺点：没有解决连续存储分配带来的表长难以确定的问题。失去了顺序存储结构随机存取的特性。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><h3 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h3><p>在p与p—&gt;next之间插入s：s—&gt;prior &#x3D; p; s—&gt;next &#x3D; p—&gt;next; p—&gt;next—&gt;prior &#x3D; s; p—&gt;next &#x3D; s;</p><p>删除p结点：p—&gt;prior—&gt;next &#x3D; p—&gt;next;  p—&gt;next—&gt;prior &#x3D; p—&gt;prior;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;p&gt;为《大话数据结构》书的第三章，线性表。线性表：零个或多个数据元素的有限序列。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第二章-算法一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/06/27/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%97%E6%B3%95%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/06/27/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%97%E6%B3%95%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-06-27T04:39:40.000Z</published>
    <updated>2024-06-27T09:12:15.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>为《大话数据结构》书的第二章，算法。算法是解决特定问题求解步骤的描述，在计算机中表现指令的有限序列，并且每条指令表示一个或多个操作。</p><h3 id="数据结构与算法的关系"><a href="#数据结构与算法的关系" class="headerlink" title="数据结构与算法的关系"></a>数据结构与算法的关系</h3><p>只谈数据结构，当然可，而且能在很短的时间就把几种重要的数据结构介绍完。听完后很可能没什么感觉，不知道这些数据结构有何用。但如果我们把相应的算法也拿来讲一讲，就会发现并感概计算机界的前辈们很牛。</p><p>在数据结构课程中，就算谈到算法，也是为了帮助理解好数据结构，并不会详细说算法的方方面面。</p><h3 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a>两种算法的比较</h3><p>从1一直加到100的算法，一般来说设计出程序都是这样：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> i, sum=<span class="number">0</span>, n=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>天才高斯的设计算法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> i, sum=<span class="number">0</span>, n=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">sum = (<span class="number">1</span>+n) * n / <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>高斯用的这种方法相当于另一种求等差数列的算法，不仅可用于1加到100，就是加到一千，一万，一亿（需要修改整型变量类型为长整型，否则会溢出），也就是瞬间的事。但如果用一般的算法，显然计算机要循环一千，一万，一亿次的加法运算。</p><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>算法是描述解决问题的方法。</p><p>算法是解决特定问题求解步骤的描述，在计算机中表现指令的有限序列，并且每条指令表示一个或多个操作。</p><p>算法定义中提到了指令，指令能被人或机器等计算装置执行。它可以是计算机指令，也可以是我们平时的语言文字。</p><p>为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一组操作都完成特定的功能，这就是算法了。</p><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p>算法具有五个基本特性：输入，输出，有穷性，确定性，可行性。</p><p>算法具有零个或多个输入。算法至少有一个或多个输出。有穷性指算法在执行有限的步骤之后，自动结束而不会无限循环，并且每一个步骤都在可接受的时间内完成。确定性指算法的每一步都具有确定的含义，不会出现二义性。可行性指算法的每一步都必须是可行的，算法能转换为程序上机运行并得到正确结果，每一步都能够通过执行有限次数完成。</p><h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><p>正确性：算法的正确性指算法至少应具有输入，输出和加工处理无歧义性，能正确反应问题的需求，能得到问题的正确答案。</p><p>用法上分为四个层次：1.算法程序没语法错误。2.算法程序对于合法的输入数据能产生满足要求的输出结果。3.算法程序对于非法的输入数据能够得出满足规格说明的结果。4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</p><p>对于这四层次，层次1要求最低，层次4最困难，几乎不可能逐一验证所有的输入都得到正确的结果。因此算法的正确性在大部分情况都不可能用程序证明，而是用数学方法证明。证明一个复杂算法在所有层次上都正确，代价非常昂贵。故一般情况下，层次3为一个算法是否正确的标准。</p><p>可读性：算法设计的另一目的是方便阅读，理解，交流。</p><p>可读性高有助于对算法的理解，晦涩难懂的算法往往隐含错误，不易发现，难于调试修改。</p><p>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p><p>一个好的算法应该对输入数据不合法的情况做合适的处理，比如输入的时间或距离不能为负数等。</p><p>时间效率高和存储量低：时间效率指算法的执行时间，存储量指算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。</p><p>综上，一个好的算法，应该具有正确性，可读性，健壮性，高效率和低存储量的特征。</p><h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><p>事后统计方法：主要通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</p><p>缺陷很多，如必须事先编好程序，比较时间较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身优劣，算法测试数据设计困难，且算法运行时间往往与测试数据规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。</p><p>事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。</p><p>一个用高级程序语言编写的程序在计算机上运行时所耗时取决下列因素：1.算法采用的策略，方法。2.编译产生的代码质量。3.问题的输入规模。4.机器执行指令的速度。</p><p>第1条当然是算法好坏的根本，第2条由软件支持，第4条看硬件性能。</p><p>一个程序运行时间，依赖于算法好坏和问题的输入规模。输入规模指输入量的多少。</p><p>举例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> i, j, x = <span class="number">0</span>, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( j =<span class="number">1</span>; j&lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当中的x++;sum +&#x3D; x;这些循环部分的代码整体需要执行n的平方次。</p><p>在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。</p><p>在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。</p><h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><p>输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一函数，我们称函数是渐近增长的。</p><p>函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是&gt;g(n)，那么f(n)的增长渐近快于g(n)。</p><p>与最高次项相乘的常数并不重要。</p><p>最高次项的指数大的，随着n的增长，函数结果也会变得增长特别快。</p><p>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应关注主项(最高阶项)的阶数。</p><p>某个算法，随着n的增大，它会越来越优于另一算法，或越来越差于另一算法。</p><h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><p>定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)&#x3D;O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p><p>一般随着n的增大，T(n)增长最慢的算法为最优算法。</p><p>O(1)叫常数阶，O(n)叫线性阶，O(n的平方)叫平方阶。</p><p>推导大O阶方法：1.用常数1取代运行时间中的所有加法常数。2.在修改后的运行次数函数中，只保留最高阶项。3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><p>所耗时间从小到大依次是：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n的平方)&lt;O(n的立方)&lt;O(2的n次方)&lt;O(n的阶乘)&lt;O(n的n次方)</p><h3 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h3><p>在查找一个有n个随机数字的数组中的某个数字，最好的情况是第一个就是，算法时间复杂度O(1)，如果在最后一个位置，算法时间复杂度就是O(n)，这是最坏情况。</p><p>最坏情况运行时间是一种保证，那就是运行时间将不会再长了，在应用中，这是一种最重要的需求，通常，除非特别指定，提到的运行时间都是最坏情况的运行时间。</p><p>平均运行时间是从概率的角度看，在每一个位置的可能性都是相同的，所以平均查找时间为n&#x2F;2次后找到此目标元素。</p><p>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。所以就有了平均时间复杂度，计算所有情况的平均值。</p><p>一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p><h3 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) &#x3D; O(f(n))，其中，n为问题规模，f(n)为语句关于n所占存储空间的函数。</p><p>若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。</p><p>当不用限定词地使用”复杂度”时，通常是指时间复杂度。</p><p>写代码时完全可用空间换取时间，比如判断某年是不是闰年，事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是闰年值为0。这样问题就变成了查找数组的某一项的值是多少。此时运算是最小化了，但硬盘上或内存中需要存储这2050个0和1。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;p&gt;为《大话数据结构》书的第二章，算法。算法是解决特定问题求解步骤的描述，在计算机中表现指令的有限序列，并且每条指令表示一个或多个操作。&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6-26做题笔记2</title>
    <link href="http://quruipeng666.github.io/2024/06/26/6-26%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/"/>
    <id>http://quruipeng666.github.io/2024/06/26/6-26%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/</id>
    <published>2024-06-26T08:45:44.000Z</published>
    <updated>2024-06-26T09:30:58.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继续刷！"><a href="#继续刷！" class="headerlink" title="继续刷！"></a>继续刷！</h2><h3 id="若用一个大小为-6-的数组来实现循环队列，且当-rear-和-front-的值分别为-0-和-3-。当从队列中删除一个元素，再加入两个元素后，rear-和-front-的值分别为-。"><a href="#若用一个大小为-6-的数组来实现循环队列，且当-rear-和-front-的值分别为-0-和-3-。当从队列中删除一个元素，再加入两个元素后，rear-和-front-的值分别为-。" class="headerlink" title="若用一个大小为 6 的数组来实现循环队列，且当 rear 和 front 的值分别为 0 和 3 。当从队列中删除一个元素，再加入两个元素后，rear 和 front 的值分别为 。"></a>若用一个大小为 6 的数组来实现循环队列，且当 rear 和 front 的值分别为 0 和 3 。当从队列中删除一个元素，再加入两个元素后，rear 和 front 的值分别为 。</h3><p>2和4</p><p>重点：队列添加元素是在队尾，删除元素是在队头； 添加元素，尾指针rear+1;删除元素，头指针front+1; 删除一个元素，front+1,也就是3+1&#x3D;4；添加2个元素，rear+2,也就是0+2&#x3D;2； 不要看反谁是谁的值。</p><h3 id="线性表的顺序存储结构是一种（随机存取）-的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。"><a href="#线性表的顺序存储结构是一种（随机存取）-的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。" class="headerlink" title="线性表的顺序存储结构是一种（随机存取） 的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。"></a>线性表的顺序存储结构是一种（随机存取） 的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。</h3><p>重点：顺序存储结构中，数据元素存放在一组地址连续的存储单元中，每个数据元素地址可通过公式LOC(ai)&#x3D;LOC(a1)+(i-1)L计算得到，从而实现了随机存取。对于链式存储结构，要对某结点进行存取，都得从链的头指针指向的结点开始，这是一种顺序存取的存储结构。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;继续刷！&quot;&gt;&lt;a href=&quot;#继续刷！&quot; class=&quot;headerlink&quot; title=&quot;继续刷！&quot;&gt;&lt;/a&gt;继续刷！&lt;/h2&gt;&lt;h3 id=&quot;若用一个大小为-6-的数组来实现循环队列，且当-rear-和-front-的值分别为-0-和-3-。当从队列中删除</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6-26做题笔记1</title>
    <link href="http://quruipeng666.github.io/2024/06/26/6-26%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/"/>
    <id>http://quruipeng666.github.io/2024/06/26/6-26%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/</id>
    <published>2024-06-26T03:56:56.000Z</published>
    <updated>2024-06-26T08:41:48.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新的一天，新挑战"><a href="#新的一天，新挑战" class="headerlink" title="新的一天，新挑战"></a>新的一天，新挑战</h2><h3 id="设二维数组A-m-n-，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc-a-0-0-求按行优先顺序存放的数组元素a-i-j-0-≤i≤m-1-0≤j≤n-1-的存储地址为"><a href="#设二维数组A-m-n-，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc-a-0-0-求按行优先顺序存放的数组元素a-i-j-0-≤i≤m-1-0≤j≤n-1-的存储地址为" class="headerlink" title="设二维数组A[m][n]，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc(a[0][0]),求按行优先顺序存放的数组元素a[i][j](0 ≤i≤m-1,0≤j≤n-1 )的存储地址为"></a>设二维数组A[m][n]，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc(a[0][0]),求按行优先顺序存放的数组元素a[i][j](0 ≤i≤m-1,0≤j≤n-1 )的存储地址为</h3><p>Loc(a[0][0])+(i乘n+j)乘k</p><p>重点：下标从0开始，不用减。下标从1开始时，i和j都需要-1。先计算偏移量，行号i乘每行个数（总列）n，再加上列号j，总体乘字节k，最后再加上基地址。</p><h3 id="用数组-M-0-N-1-用来表示一个循环队列，-FRONT-指向队头元素，REAR-指向队尾元素的后一个位置，则当前队列中的元素个数是几个？（注：队列总的元素数不会超过队列大小）"><a href="#用数组-M-0-N-1-用来表示一个循环队列，-FRONT-指向队头元素，REAR-指向队尾元素的后一个位置，则当前队列中的元素个数是几个？（注：队列总的元素数不会超过队列大小）" class="headerlink" title="用数组 M[0..N-1] 用来表示一个循环队列， FRONT 指向队头元素，REAR 指向队尾元素的后一个位置，则当前队列中的元素个数是几个？（注：队列总的元素数不会超过队列大小）"></a>用数组 M[0..N-1] 用来表示一个循环队列， FRONT 指向队头元素，REAR 指向队尾元素的后一个位置，则当前队列中的元素个数是几个？（注：队列总的元素数不会超过队列大小）</h3><p>(rear-front+n)%n</p><p>重点：队列中rear指向为下一个地址，rear-front&#x3D;已经存入的个数 。<br>由题意知队列为循环队列，rear的序号可能就比front序号小，所以需要+n再%n。</p><h3 id="选项代码中能正确操作数组元素的是"><a href="#选项代码中能正确操作数组元素的是" class="headerlink" title="选项代码中能正确操作数组元素的是()"></a>选项代码中能正确操作数组元素的是()</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> a[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//访问二维数组a的值</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//选项代码</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>(</em>(a+i)+j)&#x3D;1</p><p>*(a[i]+j)&#x3D;1</p><p>别漏选。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新的一天，新挑战&quot;&gt;&lt;a href=&quot;#新的一天，新挑战&quot; class=&quot;headerlink&quot; title=&quot;新的一天，新挑战&quot;&gt;&lt;/a&gt;新的一天，新挑战&lt;/h2&gt;&lt;h3 id=&quot;设二维数组A-m-n-，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6-25做题笔记2</title>
    <link href="http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/"/>
    <id>http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/</id>
    <published>2024-06-25T14:29:15.000Z</published>
    <updated>2024-06-25T14:59:34.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这次的题目有些经典"><a href="#这次的题目有些经典" class="headerlink" title="这次的题目有些经典"></a>这次的题目有些经典</h2><h3 id="若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1-n-全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）"><a href="#若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1-n-全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）" class="headerlink" title="若数组S[1..n]作为两个栈S1和S2的存储空间，对任何一个栈，只有当[1..n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）"></a>若数组S[1..n]作为两个栈S1和S2的存储空间，对任何一个栈，只有当[1..n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）</h3><p>S1的栈底位置为1，S2的栈底位置为n</p><p>重点：注意数组下标从1开始，栈S1的栈底位置在1，随着元素入栈，朝数组索引增加方向增加。栈S2的栈底位置在n，随元素入栈，朝数组索引减少方向增加。按照这样的方案，只有当数组S全满时才不能进行进栈操作，此时两个栈的指针设想均在数组索引最中间位置。</p><h3 id="假设有60行70列的二维数组-a-1-…60-1…70-以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素-a-32-58-的存储地址为"><a href="#假设有60行70列的二维数组-a-1-…60-1…70-以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素-a-32-58-的存储地址为" class="headerlink" title="假设有60行70列的二维数组 a[1 …60, 1…70 ] 以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素 a[ 32,58 ] 的存储地址为"></a>假设有60行70列的二维数组 a[1 …60, 1…70 ] 以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素 a[ 32,58 ] 的存储地址为</h3><p>注意：题目是说按列存储，不是按行存储！！存储第32行第58列元素之前，一共存储的元素个数为：57乘60+31&#x3D;3451，需要的存储单元数为3451乘2&#x3D;6902，又因为基地址为10000，故存储完第31行第58列元素位置为16901，所以存储第32行第58列元素地址为16902（开始）。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;这次的题目有些经典&quot;&gt;&lt;a href=&quot;#这次的题目有些经典&quot; class=&quot;headerlink&quot; title=&quot;这次的题目有些经典&quot;&gt;&lt;/a&gt;这次的题目有些经典&lt;/h2&gt;&lt;h3 id=&quot;若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6.25做题笔记1</title>
    <link href="http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/"/>
    <id>http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/</id>
    <published>2024-06-25T13:38:43.000Z</published>
    <updated>2024-06-25T13:56:53.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录"><a href="#大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录" class="headerlink" title="大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录"></a>大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录</h2><h3 id="在一个长度为n的顺序表中删除第i个元素，要移动-个元素。如果要在第i个元素前插入一个元素，要后移-个元素。"><a href="#在一个长度为n的顺序表中删除第i个元素，要移动-个元素。如果要在第i个元素前插入一个元素，要后移-个元素。" class="headerlink" title="在一个长度为n的顺序表中删除第i个元素，要移动_______个元素。如果要在第i个元素前插入一个元素，要后移_________个元素。"></a>在一个长度为n的顺序表中删除第i个元素，要移动_______个元素。如果要在第i个元素前插入一个元素，要后移_________个元素。</h3><p>删除第i个元素，要移动后面   n-i   个元素。在    第i个元素之前    插入，要移动包括    i在内的n-i+1    个元素。</p><p>重点    在第i个之前插，移动要包括那个i元素，则为n-i+1。</p><h3 id="在C-中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是-。"><a href="#在C-中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是-。" class="headerlink" title="在C++中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是( )。"></a>在C++中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是( )。</h3><p>char a1[]&#x3D; “program”;<br>char a2[]&#x3D;{‘p’,’r’,’o’,’g’,’r’,’a’,’m’}</p><p>重点    a1中存储的是字符串，因此在末尾存在字符’\0’。a2中没这个字符，故sizeof(a1)&#x3D;8，sizeof(a2)&#x3D;7，a1存储单元数目多。</p><h3 id="采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？"><a href="#采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？" class="headerlink" title="采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？"></a>采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？</h3><p>重点    不正确。假设2乘2的下三角矩阵，还有123三个元素，只是少了一个元素，没有达到节约一半的空间。</p><h3 id="在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）"><a href="#在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）" class="headerlink" title="在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）"></a>在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）</h3><p>如果数组很大的话应该是行优先快，因为数组在内存中是按行优先存储的，在虚存环境下，如果整个数组没有在内存中的话可以比列优先减少内存换进换出的次数。就算整个数组都在内存中，列优先访问a[i][j]还得计算一次乘法，行优先只需加一就可以了，这个可以忽略</p><p>分析:若在内存中,则数据可以”随机存取”,但内存数据被读取或写入时,所需要的时间与这段信息所在的位置无关.但是在读取和写入磁盘时,其所需要的时间与位置就会有关系.因为在BASIC,PASCAL和C&#x2F;C++语言中,数组的存放是按照行优先来存放的,按行号第一行第二行…以此类推.本体关键是考察内存抖动的问题,如果按列访问则需要跳过一大串内存地址,这样可能需求的内存地址不在当前页中则需要进行页置换,这样便需要硬盘IO,减低速度. </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录&quot;&gt;&lt;a href=&quot;#大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录&quot; class=&quot;headerlink&quot; title=&quot;大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0512-1</title>
    <link href="http://quruipeng666.github.io/2024/05/12/%E7%AC%94%E8%AE%B00512-1/"/>
    <id>http://quruipeng666.github.io/2024/05/12/%E7%AC%94%E8%AE%B00512-1/</id>
    <published>2024-05-12T13:03:46.000Z</published>
    <updated>2024-05-12T13:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现Player基本移动"><a href="#实现Player基本移动" class="headerlink" title="实现Player基本移动"></a>实现Player基本移动</h2><h3 id="添加必要组件"><a href="#添加必要组件" class="headerlink" title="添加必要组件"></a>添加必要组件</h3><p>Box Collider 2D设置碰撞体，设置到脚下很小的一部分碰撞体</p><p>Rigidbody 2D中的Gravity Scale改为0</p><h3 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h3><p>创建Assets–&gt;Scripts–&gt;Player处的文件，添加Player脚本绑定到Player上</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><p>思路：x，y轴的输入存到一个Vector2变量里，给到Rigidbody2D，需要float型的speed，x方向输入，y方向输入这些参数，以及一个Vector2作为移动输入变量</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监测输入函数，在Update中要调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayerInput</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if(inputY == 0)，只能横向，竖向这样走（不允许斜着走）</span></span><br><span class="line">        inputX = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="comment">//if(inputX == 0)</span></span><br><span class="line">        inputY = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//都有输入，斜方向移动</span></span><br><span class="line">        <span class="keyword">if</span>(inputX != <span class="number">0</span> &amp;&amp; inputY != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inputX = inputX * <span class="number">0.6f</span>;</span><br><span class="line">            inputY = inputY * <span class="number">0.6f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走路状态速度</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.LeftShift))</span><br><span class="line">        &#123;</span><br><span class="line">            inputX = inputX * <span class="number">0.5f</span>;</span><br><span class="line">            inputY = inputY * <span class="number">0.5f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        movementInput = <span class="keyword">new</span> Vector2(inputX, inputY);</span><br><span class="line"></span><br><span class="line">        isMoving = movementInput != Vector2.zero;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//移动函数，用到了刚体（物理），要在FixUpdate中调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Movement</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//2D横板通常用AddForce添加力，纵向的俯视角的用下边的MovePosition移动坐标的位置</span></span><br><span class="line"><span class="comment">//方法就是将它现有的坐标+movementInput这个方向性的坐标再乘速度就能实现俯视角移动</span></span><br><span class="line">        rb.MovePosition(rb.position + movementInput * speed * Time.deltaTime);</span><br><span class="line"><span class="comment">//乘Time.deltaTime为了修正在不同设备上的，不同帧数下的统一的运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现Player基本移动&quot;&gt;&lt;a href=&quot;#实现Player基本移动&quot; class=&quot;headerlink&quot; title=&quot;实现Player基本移动&quot;&gt;&lt;/a&gt;实现Player基本移动&lt;/h2&gt;&lt;h3 id=&quot;添加必要组件&quot;&gt;&lt;a href=&quot;#添加必要组件&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0511-3</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-3/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-3/</id>
    <published>2024-05-11T12:21:29.000Z</published>
    <updated>2024-05-11T12:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Player"><a href="#Player" class="headerlink" title="Player"></a>Player</h2><h3 id="创建Player"><a href="#创建Player" class="headerlink" title="创建Player"></a>创建Player</h3><p>创建Player空的父物体，设置Sorting Group，里边可以设置Sorting Layer为Instance（父及子物体看作是一个整体进行渲染），在Hierarchy中出现在下方的物体会遮盖上方物体，子物体从上往下排序：Shadow，Body，Hair，Arm</p><p>Sprite Renderer组件中的Sprite Sort Point图片渲染参考点，希望按照脚底的中心来进行排序，所以选Pivot</p><p>Sorting Layer设置对应的图层（Instance）和序，Order in Layer序号越大渲染表现越能遮盖</p><h3 id="俯视角需做小修改"><a href="#俯视角需做小修改" class="headerlink" title="俯视角需做小修改"></a>俯视角需做小修改</h3><p>随便拖个草丛进场景，在Player上下拖动并没有在上侧去到Player后方，按照Z轴方向渲染，数值越小离摄像机越近，反之越远，所以出现这种叠层关系</p><p>Editor–&gt;Project Settings–&gt;Graphics里的Transparency Sort Mode 改成Custom Axis，Y改1，Z改0</p><h3 id="锚点位置设置在底部中心"><a href="#锚点位置设置在底部中心" class="headerlink" title="锚点位置设置在底部中心"></a>锚点位置设置在底部中心</h3><p>是为了处理俯视角的物体遮罩关系</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//未完待续</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Player&quot;&gt;&lt;a href=&quot;#Player&quot; class=&quot;headerlink&quot; title=&quot;Player&quot;&gt;&lt;/a&gt;Player&lt;/h2&gt;&lt;h3 id=&quot;创建Player&quot;&gt;&lt;a href=&quot;#创建Player&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0511-2</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-2/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-2/</id>
    <published>2024-05-11T09:50:01.000Z</published>
    <updated>2024-05-11T10:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模拟经营项目"><a href="#模拟经营项目" class="headerlink" title="模拟经营项目"></a>模拟经营项目</h2><h3 id="导入素材"><a href="#导入素材" class="headerlink" title="导入素材"></a>导入素材</h3><p>在导入的素材里的Art文件夹里，例如Maps里文件名后加@20，意思是瓦片地图可以被切割的，像素单位是20，也就是一个格子里有20个像素</p><p>另外是正常的图片，还有一种是家具，是多图片构成的图片素材，切割的时候使用自动切割，单独去使用里边的图片</p><h3 id="图片设置方式"><a href="#图片设置方式" class="headerlink" title="图片设置方式"></a>图片设置方式</h3><p>以地图为例，选中它，再将Sprite Mode改成Multiple，也就是多图片构成的，Pixels Per Unit设置为20，Filter Mode改成Point(no filter)</p><p>Compression改成None，这样会适应我们要做的像素游戏。Max Size尽量不要超过2048，我们的图片是640×460，那么1024就足够了，完成后点击Apply</p><p>如何将这种图片设置方式定为预设，直接应用就行了呢？添加预设的方法是右上角问号旁边的设置按钮，点击就是选择一个预设，可以将当前的预制保存下Save，找到个文件夹设置叫Slice20，再多选要设置的图片文件，设置里选Slice20再点Apply</p><h3 id="切割图片成瓦片"><a href="#切割图片成瓦片" class="headerlink" title="切割图片成瓦片"></a>切割图片成瓦片</h3><p>点击Sprite Editor–&gt;Slice，Type选Grid By Cell Size（按照尺寸)，项目是按照20的瓦片，Pixel Size的X,Y都为20，锚点位置Pivot保持在Center（图片中心）就可以了</p><p>下边有个模式Method，里边的Smart会切割并保留我们仅有图片像素的位置，那么空白的位置将不被保留，不像以前即使你没有画任何的像素在空格的位置，它也会切割一个瓦片，性能有很大的提升</p><p>另外Smart后期对当前这个图片做额外的修改，也可以用Smart将新增的图片直接添加进去，不会破坏原有的结构，所以通常来讲都用Smart，点击Slice切割，再点Apply，那么一张图片就切好了，跟预想的一样，空白的位置并没有切割出瓦片</p><p>Player文件夹里是分各个部分的，拿工具，头，手，身体，是按照它们的动画来进行分类的，这么做的目的是可以利用只简单切换手臂并保留身体和头发的动画就实现比如跑步，举着东西跑步两种动画的切换，另外，这样分割的好处就是如果以后修改这套素材，例如人物原始的图片资源素材，如果修改了服装，样式的话，你也可以将它导入这种序列帧的动画，然后实现换装的效果，所以将它都分开了</p><p>首先同样应用在Slice20这个Preset，点击Apply后再点Sprite Editor，我们所有人物的动画都是8帧的，所以切割的时候按照Grid By Cell Count来切，Column&amp;Row分别为8,1,锚点Pivot要选在Bottom,Method选为Smart点击Slice切割</p><p>选中一个图片后，锚点是在脚下，因为俯视角游戏，希望按照y轴来进行渲染，进行图层的排序，这样的话会有很明显的遮挡的效果</p><p>家具图片，在Sprite Editor里Type使用Automatic自动切割，Pivot锚点也是底部Bottom，然后选Smart，再点Slice切割，最后点Apply</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未完待续</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模拟经营项目&quot;&gt;&lt;a href=&quot;#模拟经营项目&quot; class=&quot;headerlink&quot; title=&quot;模拟经营项目&quot;&gt;&lt;/a&gt;模拟经营项目&lt;/h2&gt;&lt;h3 id=&quot;导入素材&quot;&gt;&lt;a href=&quot;#导入素材&quot; class=&quot;headerlink&quot; title=&quot;导</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>模拟经营项目的笔记0511</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E6%A8%A1%E6%8B%9F%E7%BB%8F%E8%90%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AC%94%E8%AE%B00511/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E6%A8%A1%E6%8B%9F%E7%BB%8F%E8%90%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AC%94%E8%AE%B00511/</id>
    <published>2024-05-11T09:08:35.000Z</published>
    <updated>2024-05-11T09:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><p>本项目要求Unity引擎 编辑器版本 至少在2021.2.10f1c1以上，创建项目的时候要选中此编辑器版本才可生效</p><p>会使用到2D(URP)模板，但建议从2D核心模板开始创建项目，这样还可以学习将当前2D项目升级到通用渲染管线URP</p><h3 id="Unity2021-2-新版界面介绍（工具栏使用"><a href="#Unity2021-2-新版界面介绍（工具栏使用" class="headerlink" title="Unity2021.2 新版界面介绍（工具栏使用"></a>Unity2021.2 新版界面介绍（工具栏使用</h3><p>使用2021.2.10f1c1这样相对来说较新的版本，打开后映入眼帘的是工具栏的样式和位置，那些控制移动的图标(快捷键QWERT,可以直接隐藏，选择Scene窗口再按下空格键弹出小窗口，在里边可以选择显示哪些组件功能例如我不希望Tools显示，点击眼睛关掉即可)，原先应该在工具栏最左侧的位置，现在变成了活动可移动的窗口，拖动也可让它重回原先的位置</p><p>其中的一个按钮展开可以选择图片中心点为移动点或图片锚点为移动点，另一按钮展开为全局的移动旋转或局部的移动旋转可供显示切换</p><p>Scene场景打开灯光显示，下拉菜单打开后处理，天空盒，雾，粒子系统等等，Scene场景摄像机，网格的显示</p><p>Search功能可以搜索，例如我可以在场景当中搜索我想要的关键字，例如我调用了哪个Prefab哪个文件</p><h3 id="Package-Manager（包管理"><a href="#Package-Manager（包管理" class="headerlink" title="Package Manager（包管理"></a>Package Manager（包管理</h3><p>Window–&gt;Package Manager，打开窗口后选择Packages:In Project，可以看到当前项目中以及加载好的组件</p><p>2021.2或以上版本会出现Features分类，里边会包括目前已经内置安装好的功能，我们对里边的2D Tilemap Extras插件不陌生，里边包括规则的瓦片，动态的瓦片这些，Unity已经正式推出并包含在2D主题包当中了</p><p>可以看到有很多上箭头，我们可以选择需要的将它升级，选择不需要的将它Remove移除</p><p>没使用Plastic SCM进行版本管理，可以直接将Version Control移除</p><p>没使用可视化编程，将Visual Scripting移除，这样也可以将包体减小，加载代码快一些</p><p>如果用的Visual Studio最新版编写代码，将Visual Studio Editor升到最新，Rider同理</p><p>Timeline，Test Framework都是需要的，直接更新到最新（需要预览版本preview可以点齿轮Advanced Project Settings</p><h3 id="导入素材，小工具："><a href="#导入素材，小工具：" class="headerlink" title="导入素材，小工具："></a>导入素材，小工具：</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">接下篇</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建新项目&quot;&gt;&lt;a href=&quot;#创建新项目&quot; class=&quot;headerlink&quot; title=&quot;创建新项目&quot;&gt;&lt;/a&gt;创建新项目&lt;/h2&gt;&lt;p&gt;本项目要求Unity引擎 编辑器版本 至少在2021.2.10f1c1以上，创建项目的时候要选中此编辑器版本才可生效</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第一章.数据结构绪论一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/03/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/03/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-03-21T08:35:16.000Z</published>
    <updated>2024-06-27T04:41:36.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h2><p>此为《大话数据结构》书的第一章，数据结构绪论。鄙人正在学习此书中…特此留笔记录</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><h3 id="为什么要学数据结构？"><a href="#为什么要学数据结构？" class="headerlink" title="为什么要学数据结构？"></a>为什么要学数据结构？</h3><p>更好地去感受编程之美</p><h3 id="数据结构研究什么？"><a href="#数据结构研究什么？" class="headerlink" title="数据结构研究什么？"></a>数据结构研究什么？</h3><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科</p><h3 id="程序设计是什么？"><a href="#程序设计是什么？" class="headerlink" title="程序设计是什么？"></a>程序设计是什么？</h3><p>程序设计&#x3D;数据结构+算法</p><h3 id="数据结构能帮助到程序设计，从而解决问题？"><a href="#数据结构能帮助到程序设计，从而解决问题？" class="headerlink" title="数据结构能帮助到程序设计，从而解决问题？"></a>数据结构能帮助到程序设计，从而解决问题？</h3><p>程序设计的实质是对确定的问题选择一种好的结构，加上设计一种好的算法</p><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>所谓”巧妇难为无米之炊”，计算机再强大，也得有“米”下锅才能干活，否则就是板砖。这个“米”就是数据。</p><p>数据，是描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</p><p>数据不仅仅包括整型，实型等数值类型，还包括字符及声音，图像，视频等非数值类型</p><p>数据其实就是符号，符号，必须具备两个前提：1.可以输入到计算机中  2.能被计算机程序处理</p><p>对于整型，实型等数值类型，可以进行数值运算</p><p>对于字符数据类型，就需要进行非数值的处理。而声音，图像，视频等其实是可以通过编码的手段变成字符数据来处理的</p><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p>数据元素，是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录</p><p>在人类中，人是数据元素。畜类中，牛，马，羊，鸡，猪，狗等动物是畜类的数据元素</p><h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><p>一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位</p><p>人这个数据元素，可以有眼，耳，鼻，嘴，手，脚数据项，也可以有姓名，年龄，性别，地址，电话等数据项。具体有哪些数据项，视系统决定。</p><p>数据项是数据的最小单位，但真正讨论电影时，讨论的是电影里的角色这样的数据元素，所以数据元素才是数据结构中建立数据模型的着眼点。</p><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>数据对象，是性质相同的数据元素的集合，是数据的子集</p><p>性质相同怎么理解，人都有姓名，生日，性别等相同的数据项</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>结构，简单理解就是关系，比如分子结构，是说组成分子的原子之间的排列方式。</p><p>严格点说，结构是指各个组成部分相互搭配和排列的方式。</p><p>在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构</p><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><p>为编写一个“好”的程序，必须分析待处理对象的特性及各处理对象之间存在的关系</p><h2 id="按照视点的不同，分为逻辑结构和物理结构"><a href="#按照视点的不同，分为逻辑结构和物理结构" class="headerlink" title="按照视点的不同，分为逻辑结构和物理结构"></a>按照视点的不同，分为逻辑结构和物理结构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构，是指数据对象中数据元素之间的相互关系</p><p>逻辑结构分为四种：</p><p>1.集合结构</p><p>集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。类似数学中的集合</p><p>2.线性结构</p><p>线性结构中的数据元素之间是一对一的关系。</p><hr><p>1-2-3-4-5**<br>**********|**<br>********<strong>6</strong><br>**********|**<br>***<strong>9-8-7</strong></p><hr><p>3.树形结构</p><p>树形结构中的数据元素之间存在一种一对多的层次关系</p><hr><p><em><strong><strong><strong><strong><strong>A</strong></strong></strong></strong></strong></em>**</p><hr><p><em><strong><em><strong>B</strong></em>C</strong></em>D*********</p><hr><p><strong>E****F</strong>G<em><strong><em>H</em>I</strong>J**</em></p><hr><p>4.图形结构</p><p>图形结构的数据元素是多对多的关系</p><p>———————————————————————<br>|      |    1  |    2  |   3  |   4  |   5  |   6  |   7  |   8  |   9     |<br>|——————————————————————|<br>| 1   |        |   √  |   √  |       |       |       |       |       |          |<br>| 2   |    √  |       |       |    √ |   √  |       |      |    √ |          |<br>| 3   |    √  |       |       |       |    √  |  √  |      |        |         |<br>| 4   |        |   √  |       |       |        |       |      |    √ |   √    |<br>| 5   |        |   √  |   √  |       |        |       |  √  |       |   √    |<br>| 6   |        |       |   √  |        |       |       |  √  |       |   √    |<br>| 7   |        |       |        |       |   √  |  √   |      |       |   √    |<br>| 8   |        |   √  |        |   √ |        |       |      |       |    √   |<br>| 9   |        |       |        |   √  |   √  |  √   |  √  |   √ |         |<br>———————————————————————</p><p>我们再用示意图表示数据的逻辑结构时，要注意两点：</p><p>1.将每一个数据元素看作一个结点，用圆圈表示</p><p>2.元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示</p><p>逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>物理结构，也叫存储结构。是指数据的逻辑结构在计算机中的存储形式。</p><p>数据的存储结构应正确地反映数据元素之间的逻辑关系</p><p>数据元素的存储结构形式有两种：顺序存储和链式存储</p><p>1.顺序存储结构</p><p>顺序存储结构，是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</p><p>都按顺序排好，每个占一小段空间。数组就是这样的顺序存储结构。当建立一个9个整型数据的数组时，计算机就在内存中找了空地，按照一个整形所占位置大小乘9，开辟一段连续的空间，第一个数组数据第一个位置，第二个数据第二个位置，顺序依次排</p><p>2.链式存储结构</p><p>面对时常要变化的结构，顺序存储并不科学，因为总有插入，总有离开</p><p>链式存储结构，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的</p><p>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，通过地址就能找到相关联数据元素的位置</p><h2 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h2><p>逻辑结构是面向问题的，物理结构是面向计算机的，其基本目标是将数据及其逻辑关系存储到计算机的内存中</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型，是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</p><p>在C语言中，按照取值的不同，数据类型分为两类：</p><p>1.原子类型：不可以再分解的基本类型，包括整型，实型，字符型</p><p>2.结构类型：由若干个类型组合而成，是可以再分解的。比如，整型数组是由若干整型数据组成的</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象，是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息</p><h3 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象数据类型，是指一个数学模型及定义在该模型上的一组操作</p><p>“抽象”的意义在于数据类型的数学抽象特性</p><p>一个抽象数据类型定义了，一个数据对象，数据对象中各数据元素之间的关系及对数据元素的操作</p><p>事实上，抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p><h3 id="描述抽象数据类型的标准格式"><a href="#描述抽象数据类型的标准格式" class="headerlink" title="描述抽象数据类型的标准格式"></a>描述抽象数据类型的标准格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">操作1</span><br><span class="line">初始条件</span><br><span class="line">操作结果描述</span><br><span class="line">操作2</span><br><span class="line">......</span><br><span class="line">操作n</span><br><span class="line">......</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据，数据对象   有若干个数据元素    有若干个数据项</p><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><p>逻辑结构，分为集合结构，线性结构，树形结构，图形结构</p><p>物理结构，分为顺序存储结构，链式存储结构</p><p>抽象数据类型及其描述方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构绪论&quot;&gt;&lt;a href=&quot;#数据结构绪论&quot; class=&quot;headerlink&quot; title=&quot;数据结构绪论&quot;&gt;&lt;/a&gt;数据结构绪论&lt;/h2&gt;&lt;p&gt;此为《大话数据结构》书的第一章，数据结构绪论。鄙人正在学习此书中…特此留笔记录&lt;/p&gt;
&lt;h3 id=&quot;数据</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实现队列</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2024-03-20T13:47:51.000Z</published>
    <updated>2024-03-20T14:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p>主要使用链表实现。这是简单的实现，其他的Clear,Contains等等方法自己实践</p><h3 id="Unity中用VS编译脚本代码实现"><a href="#Unity中用VS编译脚本代码实现" class="headerlink" title="Unity中用VS编译脚本代码实现"></a>Unity中用VS编译脚本代码实现</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 实现队列 : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义队中元素的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">QueueData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队中元素的值</span></span><br><span class="line"><span class="keyword">public</span> QueueData nextItem;</span><br><span class="line"><span class="comment">//队中元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> topData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，一般作用是让参数传进来给这个定义数据结构的变量赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QueueData</span>(<span class="params">QueueData last, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//上一个进的元素（先出队）的下一个元素是当前新进的元素</span></span><br><span class="line">last.nextItem = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QueueData</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义队首元素</span></span><br><span class="line">QueueData top;</span><br><span class="line"><span class="comment">//当前定义的上一个元素</span></span><br><span class="line">QueueData lastData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队Enqueue方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断当前是第一个入队的元素</span></span><br><span class="line"><span class="keyword">if</span>(top == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队首,更新</span></span><br><span class="line">top = <span class="keyword">new</span> QueueData(data);</span><br><span class="line"><span class="comment">//把队首赋值给当前定义的上一个元素</span></span><br><span class="line">lastData = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是第一个入队的元素，不再是队首元素</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每一次新进的元素都会更新lastData</span></span><br><span class="line">lastData = <span class="keyword">new</span> QueueData(top, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队Dequeue方法，注意没参数，返回object型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Dequeue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队首元素的值，用来出队的</span></span><br><span class="line"><span class="built_in">object</span> rsl = top.topData;</span><br><span class="line"><span class="comment">//入队的地方记录了nextItem，它的下一个item就自然变成了下一个要出的元素，就把它放在队首了</span></span><br><span class="line">top = top.nextItem;</span><br><span class="line"><span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单使用下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义初始化</span></span><br><span class="line">MyQueue mq = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">mq.Enqueue(<span class="number">1</span>);</span><br><span class="line">mq.Enqueue(<span class="number">2</span>);</span><br><span class="line">mq.Enqueue(<span class="number">3</span>);</span><br><span class="line">mq.Enqueue(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队并打印</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//1</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//2</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//3</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;队列的实现&quot;&gt;&lt;a href=&quot;#队列的实现&quot; class=&quot;headerlink&quot; title=&quot;队列的实现&quot;&gt;&lt;/a&gt;队列的实现&lt;/h2&gt;&lt;p&gt;主要使用链表实现。这是简单的实现，其他的Clear,Contains等等方法自己实践&lt;/p&gt;
&lt;h3 id=&quot;Uni</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实现堆栈</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%88/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%88/</id>
    <published>2024-03-20T13:24:12.000Z</published>
    <updated>2024-03-20T13:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆栈的实现"><a href="#堆栈的实现" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h2><h3 id="Unity中用VS编译脚本代码实现"><a href="#Unity中用VS编译脚本代码实现" class="headerlink" title="Unity中用VS编译脚本代码实现"></a>Unity中用VS编译脚本代码实现</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 实现栈 : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义栈中元素的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">StackData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//栈中元素的值</span></span><br><span class="line"><span class="keyword">public</span> StackData nextItem;</span><br><span class="line"><span class="comment">//栈中元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> topData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，一般作用是让参数传进来给这个定义数据结构的变量赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StackData</span>(<span class="params">StackData next, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.nextItem = next;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个栈顶元素</span></span><br><span class="line">StackData top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈Push方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先生成这个栈中元素，栈顶元素的更新</span></span><br><span class="line">top = <span class="keyword">new</span> StackData(top, Data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈Pop方法，注意没参数，返回object型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Pop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//栈顶元素的值</span></span><br><span class="line"><span class="built_in">object</span> rsl = top.topData;</span><br><span class="line">top = top.nextItem;</span><br><span class="line"><span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单使用下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义初始化</span></span><br><span class="line">MyStack ms = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">ms.Push(<span class="number">1</span>);</span><br><span class="line">ms.Push(<span class="number">2</span>);</span><br><span class="line">ms.Push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈并打印</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//3</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//2</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆栈的实现&quot;&gt;&lt;a href=&quot;#堆栈的实现&quot; class=&quot;headerlink&quot; title=&quot;堆栈的实现&quot;&gt;&lt;/a&gt;堆栈的实现&lt;/h2&gt;&lt;h3 id=&quot;Unity中用VS编译脚本代码实现&quot;&gt;&lt;a href=&quot;#Unity中用VS编译脚本代码实现&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>队列的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T13:06:57.000Z</published>
    <updated>2024-03-20T13:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出，后进后出。（队列的队指的是排队，先来的先走，后来的后走）</p><p>需要引用using System.Collections;（object型）<br>需要引用using System.Collections.Generic;（泛型）</p><h3 id="Queue的定义"><a href="#Queue的定义" class="headerlink" title="Queue的定义"></a>Queue的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object型的队列定义及初始化，object型需要装箱拆箱类型转换，会有一定的效率损失</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型队列定义</span></span><br><span class="line">Queue&lt;<span class="built_in">int</span>&gt; queue2 = <span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">//往队列中加元素，入队操作</span></span><br><span class="line">queue.EnQueue(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">queue2.EnQueue(<span class="number">1</span>);</span><br><span class="line">queue2.EnQueue(<span class="number">2</span>);</span><br><span class="line">queue2.EnQueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队首元素先离，队列中排最前边（最先进来的）的那个元素先出了，离队操作，此处1先离开</span></span><br><span class="line"><span class="built_in">int</span> v = queue2.Dequeue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">queue2.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断入参的值v是否在队列中</span></span><br><span class="line">queue2.Contains(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//目前队列有几个元素queue2.Count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> w <span class="keyword">in</span> queue2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印w</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>对象池，ObjectPool，一开始会预先加载一定的对象在队列里，用的时候出队，用完再入队。这样是一个循环使用的状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;先进先出，后进后出。（队列的队指的是排队，先来的先走，后来的后走）&lt;/p&gt;
&lt;p&gt;需要引用using System.Collections;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>堆栈的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%A0%86%E6%A0%88%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%A0%86%E6%A0%88%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T12:47:23.000Z</published>
    <updated>2024-03-20T13:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>一种数据容器，也可以叫对象集合。Stack，先进后出，后进先出的对象集合。跟队列的先进先出，后进后出相反</p><h3 id="Stack的定义"><a href="#Stack的定义" class="headerlink" title="Stack的定义"></a>Stack的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">Stack st1 = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//压进元素，入栈操作，在栈的底部，参数为object型，类型不安全</span></span><br><span class="line">st1.Push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的倒二位，此时在栈的顶部，理解为往杯子里放海绵垫，比如拿出海绵垫时，只能先拿最上面的（后进先出）</span></span><br><span class="line">st1.Push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">st1.Push(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">st1.Push(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出元素，出栈操作，出来类型是object型，强转为初始定义的string型，再用v接收，此处v的值是d</span></span><br><span class="line"><span class="built_in">string</span> v = (<span class="built_in">string</span>)st1.Pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//st1.Count表示目前栈中元素的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到当前在栈顶元素的值，并不出栈，不执行Pop操作</span></span><br><span class="line">v = (<span class="built_in">string</span>)st1.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">st1.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前入参v的值是否存在于当前栈中</span></span><br><span class="line">st1.Contains(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> w <span class="keyword">in</span> st1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印w</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆栈&quot;&gt;&lt;a href=&quot;#堆栈&quot; class=&quot;headerlink&quot; title=&quot;堆栈&quot;&gt;&lt;/a&gt;堆栈&lt;/h2&gt;&lt;p&gt;一种数据容器，也可以叫对象集合。Stack，先进后出，后进先出的对象集合。跟队列的先进先出，后进后出相反&lt;/p&gt;
&lt;h3 id=&quot;Stack</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链表的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T11:55:36.000Z</published>
    <updated>2024-03-20T12:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p> C#里的链表有前驱和后驱，严格上说叫双向链表</p><p>需要引用using System.Collections.Generic;</p><h3 id="双向链表的定义"><a href="#双向链表的定义" class="headerlink" title="双向链表的定义"></a>双向链表的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化定义,也是泛型</span></span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点变量定义,也int型</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟List,数组是不一样的，因为它们在内存中是属于一个连续的存储空间，其实List本质底层也是数组。</span></span><br><span class="line"><span class="comment">//像链表，实际上在内存中是离散的，它的空间并不连续，而是通过两个指针，一个指针指向下一个存储位置的地址，另一个指针指向上一个存储位置的地址，链表的链指的就是指针的意思</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加首节点，值是1，前后节点都没有，整个链表里目前只有一个值</span></span><br><span class="line">node = linList.AddFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点的后边添加，一参数为节点，二参为值</span></span><br><span class="line">linList.AddAfter(node,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点的前边添加，node变成现在最新的首节点</span></span><br><span class="line">node = linList.AddBefore(node,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的长度linList.Count,此处是3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空，linList.Clear();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//linList.First.Value为第一个节点当前存的值</span></span><br><span class="line"><span class="comment">//linList.Last.Value为最后一个节点当前存的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处为首节点的前置节点的值node.Previous.Value，node.Previous已经是null了，.Value就会报错</span></span><br><span class="line"><span class="comment">//此处为首节点的下一节点的值node.Next.Value,所以在实际应用时有可能node是最后一个节点，node.Next需要先判断不是null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加到最后一个节点</span></span><br><span class="line">linList.AddLast();</span><br></pre></td></tr></table></figure><h3 id="链表，List，数组。优缺点"><a href="#链表，List，数组。优缺点" class="headerlink" title="链表，List，数组。优缺点"></a>链表，List，数组。优缺点</h3><p>List，数组都是顺序存储，存储空间是连续的，尤其对于List来说，因为数组是不变长度的，List是预先定义了一个较长的数组，在中间添加或移除之后，它会将整个的数组进行位移，比如把索引位为3的值删除掉了，那么索引位为4，5，6直到最后一个都会往前挪一位，那么这样的操作也是比较有消耗的。<br>但对于链表来说，因为本身的存储空间就是离散的，只靠指针连接，那么当删除或插入的时候，仅仅改变的是指针的指向，效率会高于List和数组。<br>但链表在查找的时候，只能通过Next,Previous,First,Last去找到节点，并不能通过索引直接拿到，查找速度只能靠一个一个遍历，而数组，List都可以通过索引位直接拿，查找时间复杂度是O(1)，而对链表来说是O(n)，链表查找的时候效率比较低</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt; C#里的链表有前驱和后驱，严格上说叫双向链表&lt;/p&gt;
&lt;p&gt;需要引用using System.Collections.Generic;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HashSet的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/19/HashSet%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/19/HashSet%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-19T14:37:25.000Z</published>
    <updated>2024-03-19T15:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>用来存储一个不能重复的，包含着不重复项的无序列表</p><p>需要引用using System.Collections.Generic;</p><h3 id="HashSet的定义"><a href="#HashSet的定义" class="headerlink" title="HashSet的定义"></a>HashSet的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">HashSet&lt;<span class="built_in">int</span>&gt; hs1 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">HashSet&lt;<span class="built_in">int</span>&gt; hs2 = <span class="keyword">new</span> HashSet&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加值到hs1</span></span><br><span class="line">hs1.Add(<span class="number">1</span>);</span><br><span class="line">hs1.Add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//加了两次2，实际上相当于加一次2</span></span><br><span class="line">hs1.Add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//长度hs1.Count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">hs1.Remove();</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含</span></span><br><span class="line">hs1.Contains();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">hs1.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//给hs2添加值</span></span><br><span class="line">hs2.Add(<span class="number">2</span>);</span><br><span class="line">hs2.Add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集，hs1只剩2</span></span><br><span class="line">hs1.IntersectWith(hs2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时打印hs1是类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> v <span class="keyword">in</span> hs1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印v</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">hs1.UnionWith(hs2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集，hs2里有的元素，在hs1里如果有就把它去掉，没有无操作</span></span><br><span class="line">hs1.ExceptWith(hs2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对称差集，把hs1中和hs2中交集的部分去掉，只留下剩下的那个元素，无论hs1调用还是hs2调用，作用都一样</span></span><br><span class="line">hs1.SymmetricExceptWith(hs2);</span><br></pre></td></tr></table></figure><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p>它是另外一种容器，主要的作用可以用来帮助我们做刚才的集合的操作，并且我们在使用的时候，如果你的元素是唯一的不重复的，比如排名，是不重复的，对于这样的需求，我们可以考虑是否使用set来帮助我们进行存储，但是我们要知道如果使用List，还可以很方便的使用它的排序。set本身没有排序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashSet&quot;&gt;&lt;a href=&quot;#HashSet&quot; class=&quot;headerlink&quot; title=&quot;HashSet&quot;&gt;&lt;/a&gt;HashSet&lt;/h2&gt;&lt;p&gt;用来存储一个不能重复的，包含着不重复项的无序列表&lt;/p&gt;
&lt;p&gt;需要引用using System.C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity面试题基础</title>
    <link href="http://quruipeng666.github.io/2024/03/17/Unity%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/"/>
    <id>http://quruipeng666.github.io/2024/03/17/Unity%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-17T08:48:42.000Z</published>
    <updated>2024-03-17T09:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unity面试题基础"><a href="#Unity面试题基础" class="headerlink" title="Unity面试题基础"></a>Unity面试题基础</h2><h3 id="四元数的作⽤"><a href="#四元数的作⽤" class="headerlink" title="四元数的作⽤"></a>四元数的作⽤</h3><p>四元数⽤于表示旋转。</p><p>其相对于欧拉⻆的优点:</p><p>1.避免万向锁</p><p>2.只需要⼀个4维的四元数就可以执⾏绕任意过原点的向量的旋转，⽅便快捷，在某些实现下⽐旋转矩阵效率更⾼</p><p>3.可以提供平滑插值</p><p>什么是欧拉⻆:</p><p>⽤⼀句话说，欧拉⻆就是物体绕坐标系三个坐标轴(x,y,z轴）的旋转⻆度</p><p>静态：</p><p>即绕世界坐标系三个轴的旋转，由于物体旋转过程中坐标轴保持静⽌，所以称为静态</p><p>动态：</p><p>即绕物体坐标系三个轴的旋转，由于物体旋转过程中坐标轴随着物体做相同的转动，所以称为动态。 </p><p>物体的任何⼀种旋转都可分解为分别绕三个轴的旋转，但分解⽅式不唯⼀。</p><p>unity 3D欧拉⻆的旋转顺序（⽗⼦关系）是y-x-z。</p><p>unity中最简单的万向锁就是先让X轴旋转90度，z轴旋转和y轴旋转效果是⼀样。</p><h3 id="Unity脚本⽣命周期与执⾏顺序"><a href="#Unity脚本⽣命周期与执⾏顺序" class="headerlink" title="Unity脚本⽣命周期与执⾏顺序"></a>Unity脚本⽣命周期与执⾏顺序</h3><p>格式按照  名称；触发时机；用途（有的不包括此条）</p><p>Awake；脚本实例被创建时调用；用于游戏对象的初始化，注意Awake的执行早于所有脚本的Start函数</p><p>OnEnable；当对象变为可用或激活状态时被调用</p><p>Start；Update函数第一次运行之前调用；用于游戏对象的初始化</p><p>Update；每帧调用一次；用于更新游戏场景和状态</p><p>FixedUpdate；每个固定物理时间间隔调用一次；用于物理状态的更新</p><p>LateUpdate；每帧调用一次（在Update之后调用）；用于更新游戏场景和状态，和相机有关的更新一般放在这里</p><p>OnGUI；渲染和处理OnGUI事件</p><p>OnDisable；当前对象不可用或非激活状态时被调用</p><p>OnDestroy；当前对象被销毁时调用</p><h3 id="理解Unity协程"><a href="#理解Unity协程" class="headerlink" title="理解Unity协程"></a>理解Unity协程</h3><p>协程不是线程。协程的实现原理是迭代器，⽽迭代器的实现原理是状态机。</p><p>unity中协程执⾏过程中，通过 yield return XXX，将程序挂起，去执⾏接下来的内容。在遇到 yield return XXX语句之前，协程⽅法和⼀般的⽅法是相同的，也就是程序在执⾏到 yield return XXX语句之后，接着才会执⾏的是 StartCoroutine()⽅法之后的程序，⾛的还是单线程模式，仅仅是将 yield return XXX语句之后的内容暂时挂起，等到特定的时间才执⾏。</p><p>那么挂起的程序什么时候才执⾏？协同程序主要是Update()⽅法之后，LateUpdate()⽅法之前调⽤的。</p><p>通过设置MonoBehaviour脚本的enabled对协程是没有影响的，但如果gameObject.SetActive(false)则已经启动的协程则完全停⽌了，即使在Inspector把gameObject激活还是没有继续执⾏。也就说协程虽然是在MonoBehvaviour启动的（StartCoroutine），但是协程函数的地位完全是跟MonoBehaviour是⼀个层次的，不受MonoBehaviour的状态影响，但跟MonoBehaviour脚本⼀样受gameObject控制，也应该是和MonoBehaviour脚本⼀样每帧轮询yield 的条件是否满⾜</p><h3 id="Unity的碰撞器-Collider-与触发器-Trigger-区别"><a href="#Unity的碰撞器-Collider-与触发器-Trigger-区别" class="headerlink" title="Unity的碰撞器(Collider)与触发器(Trigger)区别"></a>Unity的碰撞器(Collider)与触发器(Trigger)区别</h3><p>碰撞器（Collider）有碰撞效果，IsTrigger&#x3D;false，可以调⽤OnCollisionEnter&#x2F;Stay&#x2F;Exit函数</p><p>触发器(Trigger)没有碰撞效果，isTrigger&#x3D;true，可以调⽤OnTriggerEnter&#x2F;Stay&#x2F;Exit函数</p><h3 id="物体发⽣碰撞的必要条件"><a href="#物体发⽣碰撞的必要条件" class="headerlink" title="物体发⽣碰撞的必要条件"></a>物体发⽣碰撞的必要条件</h3><p>必须带有collider碰撞器和rigibody刚体属性或者⼈物控制器，其实⼈物控制器就包含了前两者，另外⼀个物体也要必须带有Collider，</p><p>Collider分类：⽹格碰撞器，盒⼦碰撞器，胶囊碰撞器，球型碰撞器，地形碰撞器</p><h3 id="CharacterController与Rigidbody的区别"><a href="#CharacterController与Rigidbody的区别" class="headerlink" title="CharacterController与Rigidbody的区别"></a>CharacterController与Rigidbody的区别</h3><p>Rigidbody具有完全真实物理的特性，⽽CharacterController可以说是受限的的Rigidbody，具有⼀定的物理效果但不是完全真实的</p><h3 id="物体发⽣碰撞时，有⼏个阶段和分别对应的函数"><a href="#物体发⽣碰撞时，有⼏个阶段和分别对应的函数" class="headerlink" title="物体发⽣碰撞时，有⼏个阶段和分别对应的函数"></a>物体发⽣碰撞时，有⼏个阶段和分别对应的函数</h3><p>三个阶段，OnCollisionEnter&#x2F;Stay&#x2F;Exit函数</p><h3 id="物体发⽣碰撞时，⼏种施加压⼒的⽅式"><a href="#物体发⽣碰撞时，⼏种施加压⼒的⽅式" class="headerlink" title="物体发⽣碰撞时，⼏种施加压⼒的⽅式"></a>物体发⽣碰撞时，⼏种施加压⼒的⽅式</h3><p>rigidbody.AddForce&#x2F;AddForceAtPosition,都是rigidbody的成员函数</p><h3 id="Unity3d提供了⼏种光源"><a href="#Unity3d提供了⼏种光源" class="headerlink" title="Unity3d提供了⼏种光源"></a>Unity3d提供了⼏种光源</h3><p>共4种，DirectionalLight、PointLight、SpotLight、AreaLight（⽤于烘焙）</p><h3 id="物理更新⼀般在哪个系统函数⾥"><a href="#物理更新⼀般在哪个系统函数⾥" class="headerlink" title="物理更新⼀般在哪个系统函数⾥"></a>物理更新⼀般在哪个系统函数⾥</h3><p>FixedUpdate,每固定帧绘制时执⾏⼀次，和update不同的是FixedUpdate是渲染帧执⾏，如果你的渲染帧效率低下的时候FixedUpdate调⽤次数就会跟着下降。FixedUpdate⽐较适合⽤于物理引擎的计算，因为是跟每帧的渲染有关。Update就⽐较适合做控制</p><h3 id="移动相机动作在哪个函数⾥，为什么在这个函数⾥"><a href="#移动相机动作在哪个函数⾥，为什么在这个函数⾥" class="headerlink" title="移动相机动作在哪个函数⾥，为什么在这个函数⾥"></a>移动相机动作在哪个函数⾥，为什么在这个函数⾥</h3><p>LateUpdate，是在所有的update结束后才调⽤，⽐较适合⽤于命令脚本的执⾏。官⽹上例⼦是摄像机的跟随，都是所有的update操作完才进⾏摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视⻆⾥还未有⻆⾊的空帧出现</p><h3 id="简述Prefab的⽤处"><a href="#简述Prefab的⽤处" class="headerlink" title="简述Prefab的⽤处"></a>简述Prefab的⽤处</h3><p>在游戏运⾏时实例化，prefab相当于⼀个模板，对你已经有的素材、脚本、参数做⼀个默认的配置，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流</p><h3 id="简述对象池-在FPS游戏⾥哪些东⻄适合使⽤对象池"><a href="#简述对象池-在FPS游戏⾥哪些东⻄适合使⽤对象池" class="headerlink" title="简述对象池,在FPS游戏⾥哪些东⻄适合使⽤对象池"></a>简述对象池,在FPS游戏⾥哪些东⻄适合使⽤对象池</h3><p>对象池就存放需要被反复调⽤资源的⼀个空间，⽐如游戏中要常被⼤量复制的对象，⼦弹，敌⼈，以及任何重复出现的对象</p><h3 id="如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法"><a href="#如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法" class="headerlink" title="如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法"></a>如何安全的在不同⼯程间安全地迁移asset数据？三种⽅法</h3><p>1.将Assets和Library⼀起迁移</p><p>2.导出包package</p><p>3.⽤unity⾃带的assets Server功能</p><h3 id="OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣"><a href="#OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣" class="headerlink" title="OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣"></a>OnEnable、Awake、Start运⾏时的发⽣顺序？哪些可能在同⼀个对象周期中反复的发⽣</h3><p>Awake–&gt;OnEnable-&gt;Start，OnEnable在同⼀周期中可以反复地发⽣</p><h3 id="MeshRender中material和sharedmaterial的区别"><a href="#MeshRender中material和sharedmaterial的区别" class="headerlink" title="MeshRender中material和sharedmaterial的区别"></a>MeshRender中material和sharedmaterial的区别</h3><p>修改sharedMaterial将改变所有物体使⽤这个材质的外观，并且也改变储存在⼯程⾥的材质设置</p><p>不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使⽤material替代</p><h3 id="TCP-IP协议栈各个层次及分别的功能"><a href="#TCP-IP协议栈各个层次及分别的功能" class="headerlink" title="TCP&#x2F;IP协议栈各个层次及分别的功能"></a>TCP&#x2F;IP协议栈各个层次及分别的功能</h3><p>⽹络接⼝层：这是协议栈的最低层，对应OSI的物理层和数据链路层，主要完成数据帧的实际发送和接收</p><p>⽹络层：处理分组在⽹络中的活动，例如路由选择和转发等，这⼀层主要包括IP协议、ARP、ICMP协议等</p><p>传输层：主要功能是提供应⽤程序之间的通信，这⼀层主要是TCP&#x2F;UDP协议</p><p>应⽤层：⽤来处理特定的应⽤，针对不同的应⽤提供了不同的协议，例如进⾏⽂件传输时⽤到的FTP协议，发送email⽤到的SMTP等</p><h3 id="Unity提供了⼏种光源"><a href="#Unity提供了⼏种光源" class="headerlink" title="Unity提供了⼏种光源"></a>Unity提供了⼏种光源</h3><p>四种。 平⾏光：Directional Light     点光源：Point Light      聚光灯：Spot Light      区域光源：Area Light</p><h3 id="GPU的⼯作原理"><a href="#GPU的⼯作原理" class="headerlink" title="GPU的⼯作原理"></a>GPU的⼯作原理</h3><p>简⽽⾔之，GPU的图形（处理）流⽔线完成如下的⼯作：（并不⼀定是按照如下顺序）</p><p>1.顶点处理：</p><p>这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建⽴起3D图形的⻣架。在⽀持DX8和DX9规格的GPU中，这些⼯作由硬件实现的Vertex Shader（定点着⾊器）完成</p><p>2.光栅化计算：</p><p>显示器实际显示的图像是由像素组成的，我们需要将上⾯⽣成的图形上的点和线通过⼀定的算法转换到相应的像素点。把⼀个⽮量图形转换为⼀系列像素点的过程就称为光栅化。例如，⼀条数学表示的斜线段，最终被转化成阶梯状的连续像素点</p><p>3.纹理帖图：</p><p>顶点单元⽣成的多边形只构成了3D物体的轮廓，⽽纹理映射（texture mapping）⼯作完成对多变形表⾯的帖图，通俗的说，就是将多边形的表⾯贴上相应的图⽚，从⽽⽣成“真实”的图形。TMU（Texture mapping unit）即是⽤来完成此项⼯作</p><p>4.像素处理：</p><p>这阶段（在对每个像素进⾏光栅化处理期间）GPU完成对像素的计算和处理，从⽽确定每个像素的最终属性。在⽀持DX8和DX9规格的GPU中，这些⼯作由硬件实现的Pixel Shader（像素着⾊器）完成</p><p>5.最终输出：</p><p>由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区</p><p>6.总结：</p><p>GPU的⼯作通俗的来说就是完成3D图形的⽣成，将图形映射到相应的像素点上，对每个像素进⾏计算确定最终颜⾊并完成输出</p><h3 id="什么是渲染管道"><a href="#什么是渲染管道" class="headerlink" title="什么是渲染管道"></a>什么是渲染管道</h3><p>是指在显示器上为了显示出图像⽽经过的⼀系列必要操作。 渲染管道中的很多步骤，都要将⼏何物体从⼀个坐标系中变换到另⼀个坐标系中去</p><p>主要步骤：</p><p>本地坐标-&gt;视图坐标-&gt;背⾯裁剪-&gt;光照-&gt;裁剪-&gt;投影-&gt;视图变换-&gt;光栅化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Unity面试题基础&quot;&gt;&lt;a href=&quot;#Unity面试题基础&quot; class=&quot;headerlink&quot; title=&quot;Unity面试题基础&quot;&gt;&lt;/a&gt;Unity面试题基础&lt;/h2&gt;&lt;h3 id=&quot;四元数的作⽤&quot;&gt;&lt;a href=&quot;#四元数的作⽤&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>泛型容器一一字典</title>
    <link href="http://quruipeng666.github.io/2024/03/17/%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E4%B8%80%E4%B8%80%E5%AD%97%E5%85%B8/"/>
    <id>http://quruipeng666.github.io/2024/03/17/%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E4%B8%80%E4%B8%80%E5%AD%97%E5%85%B8/</id>
    <published>2024-03-17T08:22:09.000Z</published>
    <updated>2024-03-17T08:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>泛型容器，存储键&#x2F;值对的数据的集合。键&#x2F;值对的类型必须是预先定义好的，类型安全。</p><h3 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a>字典的定义</h3><p>使用字典需要引用using System.Collections.Generic;</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化一个key是string类型，value也是string型的字典</span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; dic1 = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">dic1.Add(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;100&quot;</span>);</span><br><span class="line">dic1.Add(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;200&quot;</span>);</span><br><span class="line">dic1.Add(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;300&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在键</span></span><br><span class="line"><span class="keyword">if</span>(dic1.ContainsKey(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印（存在&quot;1&quot;键）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">dic1[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;1000&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历，另一种取出所有键方式也行</span></span><br><span class="line"><span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; kvp <span class="keyword">in</span> dic1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印每一对 键/值对 的 kvp.Key 和 kvp.Value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">dic1.Remove(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">dic1.Clear();</span><br></pre></td></tr></table></figure><p>字典跟哈希表的使用方式非常像</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>字典定义时需要是泛型，需要指定好类型，这样的话在使用的时候就没有装箱拆箱类型转换那一步，执行效率非常高。<br>哈希表在Add（key，value）时都是object类型的，必须会多了装箱拆箱类型转换这个操作，执行效率会低一些。</p><h3 id="了解概念"><a href="#了解概念" class="headerlink" title="了解概念"></a>了解概念</h3><p>线程安全，线程不安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h2&gt;&lt;p&gt;泛型容器，存储键&amp;#x2F;值对的数据的集合。键&amp;#x2F;值对的类型必须是预先定义好的，类型安全。&lt;/p&gt;
&lt;h3 id=&quot;字典的定义&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>哈希table一一Hashtable</title>
    <link href="http://quruipeng666.github.io/2024/03/17/%E5%93%88%E5%B8%8Ctable%E4%B8%80%E4%B8%80Hashtable/"/>
    <id>http://quruipeng666.github.io/2024/03/17/%E5%93%88%E5%B8%8Ctable%E4%B8%80%E4%B8%80Hashtable/</id>
    <published>2024-03-17T08:02:36.000Z</published>
    <updated>2024-03-17T08:20:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>中文全称叫 哈希表。它是一个集合容器。Hashtable类代表了基于键的哈希代码组织起来的 键&#x2F;值 对 的集合。</p><p>每存储一个元素，都有一个键以及这个键所对应的一个值，也叫键&#x2F;值对，它使用键来访问集合中的元素。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">Hashtable ht1 = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型不安全，key(键)，value(值)都是Object类型。</span></span><br><span class="line">ht1.Add(<span class="string">&quot;1&quot;</span>,<span class="number">100</span>);</span><br><span class="line">ht1.Add(<span class="number">1</span>,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作，ht1.Clear();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ht1.ContainsKey(&quot;1&quot;);判断有没有&quot;1&quot;这个键，如果有返回true，反之false。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ht1.Count有几对键值对，这里是2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除操作，ht1.Remove(&quot;1&quot;);参数是key(键)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如我们想取出字符串&quot;1&quot;键的值，就写ht1[&quot;1&quot;]</span></span><br><span class="line"><span class="comment">//比如我们想取出int型1键的值，就写ht1[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如我们想修改int型1键的值为999，就写ht1[1]=999;如果有int型1键的话才能改，否则会出现异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">ICollection key=ht1.Keys;<span class="comment">//所有键</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> k <span class="keyword">in</span> key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印ht1[k]，每一个值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hashtable&quot;&gt;&lt;a href=&quot;#Hashtable&quot; class=&quot;headerlink&quot; title=&quot;Hashtable&quot;&gt;&lt;/a&gt;Hashtable&lt;/h2&gt;&lt;p&gt;中文全称叫 哈希表。它是一个集合容器。Hashtable类代表了基于键的哈希代码组织</summary>
      
    
    
    
    
  </entry>
  
</feed>
