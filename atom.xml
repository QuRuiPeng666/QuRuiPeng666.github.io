<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GDDA</title>
  
  <subtitle>GameDesignDreamAchieve</subtitle>
  <link href="http://quruipeng666.github.io/atom.xml" rel="self"/>
  
  <link href="http://quruipeng666.github.io/"/>
  <updated>2024-07-12T14:32:48.217Z</updated>
  <id>http://quruipeng666.github.io/</id>
  
  <author>
    <name>GDQLF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第七章-图一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/07/12/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9B%BE%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/07/12/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9B%BE%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-07-12T01:55:34.000Z</published>
    <updated>2024-07-12T14:32:48.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G（V，E），其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>图不允许没有顶点。顶点之间的逻辑关系用边来表示。边集可以是空的。</p><h3 id="无向有向"><a href="#无向有向" class="headerlink" title="无向有向"></a>无向有向</h3><p>若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对（vi，vj）表示，也可以作（vj，vi）。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。</p><p>若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧。用有序偶&lt;vi，vj&gt;表示，不能写成&lt;vj，vi&gt;，vi称为弧尾，vj称为弧头。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。</p><p>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。</p><p>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n乘(n-1)条边。</p><p>对于具有n个顶点和e条边数的图，无向图0&lt;&#x3D;e&lt;&#x3D;n（n-1）&#x2F;2，有向图0&lt;&#x3D;e&lt;&#x3D;n（n-1）。</p><p>有很少条边或弧的图称为稀疏图，反之称为稠密图。</p><p>图的边或弧相关的数叫做权，这些权表示从一个顶点到另一个顶点的距离或耗费。这种带权的图称为网。</p><p>假设两个图G&#x3D;（V，{E}）和G’&#x3D;（V’，{E’}），如果V’含于V且E’含于E，则称G’为G的子图。</p><h3 id="图的顶点与边间关系"><a href="#图的顶点与边间关系" class="headerlink" title="图的顶点与边间关系"></a>图的顶点与边间关系</h3><p>假设无向图G中有边（v，v’），则称顶点v和v’互为邻接点，即v和v’相邻接，边（v，v’）依附于顶点v和v’，或者说（v，v’）与顶点v和v’相关联。</p><p>顶点v的度是和v相关联的边的数目，记为TD（v）。边数是各顶点度数和的一半。</p><p>假设有向图G中有边&lt;v，v’&gt;，则称顶点v邻接到v’，顶点v’邻接自顶点v。弧&lt;v，v’&gt;和顶点v，v’相关联。以顶点v为头的弧的数目称为v的入度，记为ID（v），以v为尾的弧的数目称为v的出度，记作OD（v）。顶点v的度为TD（v）&#x3D;ID（v）+OD（v）。</p><p>树中根结点到任意结点的路径是唯一的，但图中顶点与顶点之间的路径却是不唯一的。</p><p>路径的长度是路径上的边或弧的数目。</p><p>第一个顶点到最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p><h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><p>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点vi，vj含于E，vi和vj都是连通的，则称G是连通图。</p><p>无向图中的极大连通子图称为连通分量。要是子图，子图要是连通的，连通子图含有极大顶点数，具有极大顶点数的连通子图包含依附于这些顶点的所有边。</p><p>在有向图G中，如果对于每一对vi，vj含于V，vi不等于vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。</p><p>一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。</p><p>如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1边条，必定构成一个环。不过有n-1条边并不一定是生成树。</p><p>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。</p><p>一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>邻接矩阵：图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p><p>无向图的边数组是一个对称矩阵。</p><p>有向图讲究入度与出度，顶点v1的入度是第v1列各数之和，顶点v1的出度是第v1行的个数之和。</p><p>有向网图的邻接矩阵包含对应入度或出度的权值以及∞。</p><p>邻接表：数组与链表相结合的存储方法称为邻接表。</p><p>有向图的逆邻接表，即对每个顶点都建立一个链接为该顶点为弧头的表。</p><p>十字链表：把邻接表与逆邻接表结合起来的有向图的一种存储方法。</p><p>邻接多重表：对于无向图，ivex，jvex是与某条边依附的两个顶点在顶点表中下标。ilink指向依附顶点ivex的下一条边，同理jlink指向依附jvex的下一条边。</p><p>边集数组：边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标，终点下标和权组成。</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程叫图的遍历。</p><p>深度优先遍历，DFS。它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p>广度优先遍历，BFS。它以图中某个顶点开始为第一层，与它有边的顶点为第二层，依次类推。</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>把构造连通网的最小代价生成树称为最小生成树。</p><p>普里姆Prim算法，循环嵌套，时间复杂度O（n的平方）。假设N&#x3D;（P，{E}）是连通网，TE是N上最小生成树中边的集合。算法从U&#x3D;{u0}（u0属于V），TE&#x3D;{}开始。重复执行下述操作：在所有u属于U，v属于V-U的边（u，v）属于E中找一条代价最小的边（u0，v0）并入集合TE，同时v0并入U，直至U&#x3D;V为止。此时TE中必有n-1条边，则T&#x3D;（V，{TE}）为N的最小生成树。</p><p>克鲁斯卡尔Kruskal算法，时间复杂度O（eloge）。假设N&#x3D;（V，{E}）是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T&#x3D;{V，{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>对于非网图来说，就是两顶点之间经过的边数最少的路径。</p><p>对于网图来说，最短路径就是两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><p>迪杰斯特拉Dijkstra算法，是按路径长度递增的次序产生最短路径的算法。某个源点到其余各顶点的最短路径问题时间复杂度O（n的平方）。所有顶点到所有顶点的时间复杂度O（n的立方）。</p><p>弗洛伊德Floyd算法，求所有顶点至所有顶点的最短路径。依次将每个点作为“中间点”去做更新。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>下面两个是有向无环图的应用。无环，即图中没有回路的意思。</p><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为AOV网。</p><p>设G&#x3D;（V，E）是一个具有n个顶点的有向图，V中的顶点序列v1，v2，…，vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。则称这样的顶点序列为一个拓扑序列。</p><p>拓扑排序，就是对一个有向图构造拓扑序列的过程。构造时会有两个结果，如果此网的全部顶点都被输出，则它是不存在环的AOV网，如果输出顶点数少了，哪怕少一个，也说明这个网存在环，不是AOV网。</p><p>拓扑排序就是每次选入度为0的点，然后删除这个点和它的出边，依次放入排序序列。</p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称为AOE网。</p><p>ve事件最早开始时间，vl事件最晚开始时间，e活动最早开始时间，l活动最晚开始时间。</p><p>求ve用拓扑排序：每次选入度为0的点，然后删除这个点和它的出边。</p><p>设每个点的ve都为0，再通过拓扑排序更新完所有点的ve（选大的才更新），终点的vl和ve相等，再把所有点的vl初始值设为终点的vl，然后逆拓扑求vl：每次选出度为0的点，然后删除这个点和它的入边。也是更新（选小的才更新）。</p><p>边的最早开始时间（也就是e）是从哪个点发出来的，就是哪个点的最早开始时间（ve）。边指向哪个点，就用哪个点的最晚开始时间（vl）减去边的值，就是边的最晚开始时间（l）。</p><p>最后，边的最早开始时间（e）与边的最晚开始时间（l）相等的边，就是关键活动。这些边同时也构成了一条路径，把这条路径称为关键路径。关键路径可能不是唯一的。</p><p>关键活动就是不能拖延的活动，l-e的值就是指活动可以拖延多久。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h2&gt;&lt;p&gt;图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G（V，E），其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第六章-树一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/07/08/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A0%91%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/07/08/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%A0%91%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-07-08T07:13:17.000Z</published>
    <updated>2024-07-12T01:53:59.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树是n（n&gt;&#x3D;0）个结点的有限集。n&#x3D;0时称为空树，在任意一棵非空树中：有且仅有一个特定的称为根的结点，当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1，T2，…，Tn，其中每一个集合本身又是一棵树，并且称为根的子树。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>结点拥有的子树数称为结点的度。度为0的结点称为叶结点或终端结点，度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。</p><p>结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中结点的最大层次称为树的深度或高度。</p><p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p><p>森林是m棵互不相交的树的集合。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是n（n&gt;&#x3D;0）个结点的有限集合，该集合或者为空集（称为空二叉树）或者由一个根结点和两棵互不相交的，分别称为根节点的左子树和右子树的二叉树组成。</p><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><p>满二叉树一定是完全二叉树，完全二叉树不一定是满的。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>在二叉树的第i层上至多有2的i-1次方个结点（i&gt;&#x3D;1）。</p><p>深度为k的二叉树至多有2的k次方-1个结点（k&gt;&#x3D;1）。</p><p>对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数的n2，则n0&#x3D;n2+1。</p><p>具有n个结点的完全二叉树的深度为（log以2为底n）+1。（x）表示不大于x的最大整数。</p><p>如果对一棵有n个结点的完全二叉树（深度为（log以2为底n）+1）的结点按层序编号（从第1层到第（log以2为底n）+1层，每层从左到右），对任一结点i（1&lt;&#x3D;i&lt;&#x3D;n）有：</p><p>1.如果i&#x3D;1，则结点i是二叉树的根，无双亲，如果i&gt;1，则其双亲是结点（i&#x2F;2）。（x）表示不大于x的最大整数。</p><p>2.如果2i&gt;n，则结点i无左孩子（结点i为叶子结点），否则其左孩子是结点2i。</p><p>3.如果2i+1&gt;n，则结点i无右孩子，否则其右孩子是结点2i+1。</p><h3 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h3><p>顺序存储结构一般只用于完全二叉树。</p><h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>二叉树每个结点最多有两个孩子，设计一个数据域和两个指针域，这样的链表叫二叉链表。</p><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><p>前序遍历：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。根左右。</p><p>中序遍历：若树为空，则空操作返回，否则中序遍历根节点的左子树，然后是访问根结点，最后中序遍历右子树。左根右。</p><p>后序遍历：若树为空，则空操作返回，否则以左右根遍历。左右根。</p><p>层序遍历：若树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p><h3 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h3><p>已知一棵二叉树的前序遍历序列为ABCDEF，中序遍历序列为CBAEDF，问这棵二叉树的后序遍历结果是多少？CBEFDA。</p><p>二叉树的中序序列是ABCDEFG,后序序列是BDCAFGE，求前序序列。EACBDGF。</p><p>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</p><p>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</p><p>但已知前序和后序遍历序列，是不能确定一棵二叉树的。</p><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>将这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。</p><p>对二叉树以某种次序遍历使其变为线索二叉树的过程称作线索化。</p><p>线索化的过程就是在遍历的过程中修改空指针的过程。</p><p>在实际中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h3 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h3><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。</p><p>树的路径长度就是从树根到每一结点的路径长度之和。</p><p>结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。</p><p>带权路径长度WPL最小的二叉树称作赫夫曼树。</p><p>构造赫夫曼树的赫夫曼算法描述：</p><p>1.根据给定的n个权值构成n棵二叉树的集合F其中每棵二叉树只有一个带权根结点，其左右子树均为空。</p><p>2.在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根节点的权值之和。</p><p>3.在F中删除这两棵树，同时将新得到的二叉树加入F中。</p><p>4.重复2和3步骤，直到F只含一棵树为止，这棵树便是赫夫曼树。</p><h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3><p>规定赫夫曼树中权值左分支改为0，右分支改为1。这样从根节点到叶子结点的路径分支组成的0和1的序列便为该结点对应字符的编码。</p><p>编码中非0即1，长短不等，所以若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h2&gt;&lt;p&gt;树是n（n&amp;gt;&amp;#x3D;0）个结点的有限集。n&amp;#x3D;0时称为空树，在任意一棵非空树中：有且仅有一个特定的称为根的结点，当n&amp;gt;1时，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第五章-串一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/07/07/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%B2%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/07/07/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%B2%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-07-07T00:46:11.000Z</published>
    <updated>2024-07-07T05:28:56.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串是由零个或多个字符组成的有限序列，又名叫字符串。零个字符的串称为空串。</p><p>空格串，是只包含空格的串。空格串是有内容有长度的，而且可以不止一个空格。</p><p>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，包含子串的串称为主串。</p><p>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p><h3 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h3><p>串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</p><h3 id="KMP改进算法：next数组与nextval数组值推导"><a href="#KMP改进算法：next数组与nextval数组值推导" class="headerlink" title="KMP改进算法：next数组与nextval数组值推导"></a>KMP改进算法：next数组与nextval数组值推导</h3><p>j：123456789</p><p>模式串T：ababaaaba</p><p>next[i]：011234223</p><p>nextval[i]：010104210</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;串&quot;&gt;&lt;a href=&quot;#串&quot; class=&quot;headerlink&quot; title=&quot;串&quot;&gt;&lt;/a&gt;串&lt;/h2&gt;&lt;p&gt;串是由零个或多个字符组成的有限序列，又名叫字符串。零个字符的串称为空串。&lt;/p&gt;
&lt;p&gt;空格串，是只包含空格的串。空格串是有内容有长度的，而且可以不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第四章-栈与队列一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/06/30/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/06/30/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-06-30T07:03:48.000Z</published>
    <updated>2024-07-03T05:08:20.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>此为《大话数据结构》书的第四章，栈与队列。</p><p>栈与队列：栈是限定仅在表尾进行插入和删除操作的线性表。队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><p>存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top&#x3D;0，因此通常把空栈的判定条件定为top&#x3D;-1。</p><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>通常对于链栈来说，是不需要头结点的。基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是否溢出的问题。</p><p>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top&#x3D;NULL的时候。</p><p>对比一下顺序栈和链栈，时间复杂度是一样的，均为O（1）。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时增加了一些内存开销，但对于栈的长度无限制。</p><p>所以它们的区别和线性表中讨论的一样，如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。</p><p>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出的线性表，FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><p>在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;栈与队列&quot;&gt;&lt;a href=&quot;#栈与队列&quot; class=&quot;headerlink&quot; title=&quot;栈与队列&quot;&gt;&lt;/a&gt;栈与队列&lt;/h2&gt;&lt;p&gt;此为《大话数据结构》书的第四章，栈与队列。&lt;/p&gt;
&lt;p&gt;栈与队列：栈是限定仅在表尾进行插入和删除操作的线性表。队列是只允许</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第三章-线性表——《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/06/28/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/06/28/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-06-28T07:10:50.000Z</published>
    <updated>2024-06-29T14:30:54.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>为《大话数据结构》书的第三章，线性表。线性表：零个或多个数据元素的有限序列。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>若将线性表记为（a1，…，ai-1，ai，ai+1，…，an），则表中ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i&#x3D;1，2，…，n-1时，ai有且仅有一个直接后继，当i&#x3D;2，3，…，n时，ai有且仅有一个直接前驱。</p><p>a1——a2——…——ai-1——ai——ai+1——…——an</p><p>线性表元素个数n可以为0，称为空表。</p><h3 id="线性表的抽象数据类型定义"><a href="#线性表的抽象数据类型定义" class="headerlink" title="线性表的抽象数据类型定义"></a>线性表的抽象数据类型定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ADT 线性表（List）</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">线性表的数据对象集合为&#123;a1，a2，...，an&#125;，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">InitList（*L）：初始化操作，建立一个空的线性表L。</span><br><span class="line">ListEmpty（L）：若线性表为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">ClearList（*L）：将线性表清空。</span><br><span class="line">GetElem（L，i，*e）：将线性表L中的第i个位置元素值返回给e。</span><br><span class="line">LocateElem（L，e）：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回<span class="number">0</span>表示失败。</span><br><span class="line">ListInsert（*L，i，e）：在线性表L中的第i个位置插入新元素e。</span><br><span class="line">ListDelete（*L，i，*e）：删除线性表L中第i个位置元素，并用e返回其值。</span><br><span class="line">ListLength（L）：返回线性表L的元素个数。</span><br><span class="line">endADT</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><p>顺序存储结构需要三个属性：1.存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。2.线性表的最大存储容量：数组长度MaxSize。3.线性表的当前长度：length。</p><h3 id="数组长度与线性表长度区别"><a href="#数组长度与线性表长度区别" class="headerlink" title="数组长度与线性表长度区别"></a>数组长度与线性表长度区别</h3><p>在任意时刻，线性表的长度Length应该小于等于数组的长度MaxSize。</p><h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><p>存储器中的每个存储单元都有自己的编号，这个编号称为地址。</p><p>假设每个数据元素占用c个存储单元空间，那么线性表中的第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。</p><p>LOC（ai+1）&#x3D;LOC（ai）+c</p><p>LOC（ai）&#x3D;LOC（a1）+（i-1）乘c</p><p>通过这个公式，可以随时算出线性表中任意位置的地址，不管是第一个还是最后一个，都是相同时间。那么对每个线性表位置的存取数据，对于计算机来说都是相等时间，也就是一个常数，存取时间性能为O（1）。通常把具有这一特点的存储结构称为随机存取结构。</p><h3 id="线性表链式存储结构"><a href="#线性表链式存储结构" class="headerlink" title="线性表链式存储结构"></a>线性表链式存储结构</h3><p>头结点的数据域一般存储链表的长度，头结点的指针域存储指向第一个结点的指针，最后一个结点的指针指向空。</p><p>头指针就是链表指向第一个结点的指针，具有标识作用，常用它冠以链表的名字。</p><p>无论链表是否为空，头指针均不为空（空链表时，头指针指向一个双域全空的结点）。头指针是链表的必要元素。头结点不一定是链表必须要素。</p><p>若线性表为空表，则头结点的指针域为空，表示空链表。</p><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>在p与p—&gt;next之间插入s：s—&gt;next &#x3D; p—&gt;next；p—&gt;next &#x3D; s；</p><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p>在p后删除q：q &#x3D; p—&gt;next；p—&gt;next &#x3D; q—&gt;next；</p><p>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。如希望从第i个位置，插入10个元素。</p><h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p>存储分配方式上，顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。</p><p>时间性能上，查找：顺序存储结构O（1）。单链表O（n）。插入和删除：顺序存储结构需要平均移动表长一半的元素，时间为O（n）。单链表在找出某位置的指针后，插入和删除时间仅为O（1）。</p><p>空间性能上，顺序存储结构需要预分配存储空间，分大了浪费，分小了易发生上溢。单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。</p><h3 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h3><p>优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p><p>缺点：没有解决连续存储分配带来的表长难以确定的问题。失去了顺序存储结构随机存取的特性。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><h3 id="双向链表的插入"><a href="#双向链表的插入" class="headerlink" title="双向链表的插入"></a>双向链表的插入</h3><p>在p与p—&gt;next之间插入s：s—&gt;prior &#x3D; p; s—&gt;next &#x3D; p—&gt;next; p—&gt;next—&gt;prior &#x3D; s; p—&gt;next &#x3D; s;</p><p>删除p结点：p—&gt;prior—&gt;next &#x3D; p—&gt;next;  p—&gt;next—&gt;prior &#x3D; p—&gt;prior;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;p&gt;为《大话数据结构》书的第三章，线性表。线性表：零个或多个数据元素的有限序列。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第二章-算法一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/06/27/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%97%E6%B3%95%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/06/27/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%97%E6%B3%95%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-06-27T04:39:40.000Z</published>
    <updated>2024-06-27T09:12:15.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>为《大话数据结构》书的第二章，算法。算法是解决特定问题求解步骤的描述，在计算机中表现指令的有限序列，并且每条指令表示一个或多个操作。</p><h3 id="数据结构与算法的关系"><a href="#数据结构与算法的关系" class="headerlink" title="数据结构与算法的关系"></a>数据结构与算法的关系</h3><p>只谈数据结构，当然可，而且能在很短的时间就把几种重要的数据结构介绍完。听完后很可能没什么感觉，不知道这些数据结构有何用。但如果我们把相应的算法也拿来讲一讲，就会发现并感概计算机界的前辈们很牛。</p><p>在数据结构课程中，就算谈到算法，也是为了帮助理解好数据结构，并不会详细说算法的方方面面。</p><h3 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a>两种算法的比较</h3><p>从1一直加到100的算法，一般来说设计出程序都是这样：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> i, sum=<span class="number">0</span>, n=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>天才高斯的设计算法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> i, sum=<span class="number">0</span>, n=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">sum = (<span class="number">1</span>+n) * n / <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>高斯用的这种方法相当于另一种求等差数列的算法，不仅可用于1加到100，就是加到一千，一万，一亿（需要修改整型变量类型为长整型，否则会溢出），也就是瞬间的事。但如果用一般的算法，显然计算机要循环一千，一万，一亿次的加法运算。</p><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>算法是描述解决问题的方法。</p><p>算法是解决特定问题求解步骤的描述，在计算机中表现指令的有限序列，并且每条指令表示一个或多个操作。</p><p>算法定义中提到了指令，指令能被人或机器等计算装置执行。它可以是计算机指令，也可以是我们平时的语言文字。</p><p>为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一组操作都完成特定的功能，这就是算法了。</p><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p>算法具有五个基本特性：输入，输出，有穷性，确定性，可行性。</p><p>算法具有零个或多个输入。算法至少有一个或多个输出。有穷性指算法在执行有限的步骤之后，自动结束而不会无限循环，并且每一个步骤都在可接受的时间内完成。确定性指算法的每一步都具有确定的含义，不会出现二义性。可行性指算法的每一步都必须是可行的，算法能转换为程序上机运行并得到正确结果，每一步都能够通过执行有限次数完成。</p><h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><p>正确性：算法的正确性指算法至少应具有输入，输出和加工处理无歧义性，能正确反应问题的需求，能得到问题的正确答案。</p><p>用法上分为四个层次：1.算法程序没语法错误。2.算法程序对于合法的输入数据能产生满足要求的输出结果。3.算法程序对于非法的输入数据能够得出满足规格说明的结果。4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</p><p>对于这四层次，层次1要求最低，层次4最困难，几乎不可能逐一验证所有的输入都得到正确的结果。因此算法的正确性在大部分情况都不可能用程序证明，而是用数学方法证明。证明一个复杂算法在所有层次上都正确，代价非常昂贵。故一般情况下，层次3为一个算法是否正确的标准。</p><p>可读性：算法设计的另一目的是方便阅读，理解，交流。</p><p>可读性高有助于对算法的理解，晦涩难懂的算法往往隐含错误，不易发现，难于调试修改。</p><p>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</p><p>一个好的算法应该对输入数据不合法的情况做合适的处理，比如输入的时间或距离不能为负数等。</p><p>时间效率高和存储量低：时间效率指算法的执行时间，存储量指算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。</p><p>综上，一个好的算法，应该具有正确性，可读性，健壮性，高效率和低存储量的特征。</p><h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><p>事后统计方法：主要通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</p><p>缺陷很多，如必须事先编好程序，比较时间较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身优劣，算法测试数据设计困难，且算法运行时间往往与测试数据规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。</p><p>事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。</p><p>一个用高级程序语言编写的程序在计算机上运行时所耗时取决下列因素：1.算法采用的策略，方法。2.编译产生的代码质量。3.问题的输入规模。4.机器执行指令的速度。</p><p>第1条当然是算法好坏的根本，第2条由软件支持，第4条看硬件性能。</p><p>一个程序运行时间，依赖于算法好坏和问题的输入规模。输入规模指输入量的多少。</p><p>举例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> i, j, x = <span class="number">0</span>, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( j =<span class="number">1</span>; j&lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当中的x++;sum +&#x3D; x;这些循环部分的代码整体需要执行n的平方次。</p><p>在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。</p><p>在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。</p><h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><p>输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一函数，我们称函数是渐近增长的。</p><p>函数的渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是&gt;g(n)，那么f(n)的增长渐近快于g(n)。</p><p>与最高次项相乘的常数并不重要。</p><p>最高次项的指数大的，随着n的增长，函数结果也会变得增长特别快。</p><p>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应关注主项(最高阶项)的阶数。</p><p>某个算法，随着n的增大，它会越来越优于另一算法，或越来越差于另一算法。</p><h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><p>定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)&#x3D;O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p><p>一般随着n的增大，T(n)增长最慢的算法为最优算法。</p><p>O(1)叫常数阶，O(n)叫线性阶，O(n的平方)叫平方阶。</p><p>推导大O阶方法：1.用常数1取代运行时间中的所有加法常数。2.在修改后的运行次数函数中，只保留最高阶项。3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><p>所耗时间从小到大依次是：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n的平方)&lt;O(n的立方)&lt;O(2的n次方)&lt;O(n的阶乘)&lt;O(n的n次方)</p><h3 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h3><p>在查找一个有n个随机数字的数组中的某个数字，最好的情况是第一个就是，算法时间复杂度O(1)，如果在最后一个位置，算法时间复杂度就是O(n)，这是最坏情况。</p><p>最坏情况运行时间是一种保证，那就是运行时间将不会再长了，在应用中，这是一种最重要的需求，通常，除非特别指定，提到的运行时间都是最坏情况的运行时间。</p><p>平均运行时间是从概率的角度看，在每一个位置的可能性都是相同的，所以平均查找时间为n&#x2F;2次后找到此目标元素。</p><p>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。所以就有了平均时间复杂度，计算所有情况的平均值。</p><p>一般在没有特殊说明的情况下，都是指最坏时间复杂度。</p><h3 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) &#x3D; O(f(n))，其中，n为问题规模，f(n)为语句关于n所占存储空间的函数。</p><p>若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。</p><p>当不用限定词地使用”复杂度”时，通常是指时间复杂度。</p><p>写代码时完全可用空间换取时间，比如判断某年是不是闰年，事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是闰年值为0。这样问题就变成了查找数组的某一项的值是多少。此时运算是最小化了，但硬盘上或内存中需要存储这2050个0和1。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;p&gt;为《大话数据结构》书的第二章，算法。算法是解决特定问题求解步骤的描述，在计算机中表现指令的有限序列，并且每条指令表示一个或多个操作。&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6-26做题笔记2</title>
    <link href="http://quruipeng666.github.io/2024/06/26/6-26%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/"/>
    <id>http://quruipeng666.github.io/2024/06/26/6-26%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/</id>
    <published>2024-06-26T08:45:44.000Z</published>
    <updated>2024-06-26T09:30:58.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继续刷！"><a href="#继续刷！" class="headerlink" title="继续刷！"></a>继续刷！</h2><h3 id="若用一个大小为-6-的数组来实现循环队列，且当-rear-和-front-的值分别为-0-和-3-。当从队列中删除一个元素，再加入两个元素后，rear-和-front-的值分别为-。"><a href="#若用一个大小为-6-的数组来实现循环队列，且当-rear-和-front-的值分别为-0-和-3-。当从队列中删除一个元素，再加入两个元素后，rear-和-front-的值分别为-。" class="headerlink" title="若用一个大小为 6 的数组来实现循环队列，且当 rear 和 front 的值分别为 0 和 3 。当从队列中删除一个元素，再加入两个元素后，rear 和 front 的值分别为 。"></a>若用一个大小为 6 的数组来实现循环队列，且当 rear 和 front 的值分别为 0 和 3 。当从队列中删除一个元素，再加入两个元素后，rear 和 front 的值分别为 。</h3><p>2和4</p><p>重点：队列添加元素是在队尾，删除元素是在队头； 添加元素，尾指针rear+1;删除元素，头指针front+1; 删除一个元素，front+1,也就是3+1&#x3D;4；添加2个元素，rear+2,也就是0+2&#x3D;2； 不要看反谁是谁的值。</p><h3 id="线性表的顺序存储结构是一种（随机存取）-的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。"><a href="#线性表的顺序存储结构是一种（随机存取）-的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。" class="headerlink" title="线性表的顺序存储结构是一种（随机存取） 的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。"></a>线性表的顺序存储结构是一种（随机存取） 的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。</h3><p>重点：顺序存储结构中，数据元素存放在一组地址连续的存储单元中，每个数据元素地址可通过公式LOC(ai)&#x3D;LOC(a1)+(i-1)L计算得到，从而实现了随机存取。对于链式存储结构，要对某结点进行存取，都得从链的头指针指向的结点开始，这是一种顺序存取的存储结构。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;继续刷！&quot;&gt;&lt;a href=&quot;#继续刷！&quot; class=&quot;headerlink&quot; title=&quot;继续刷！&quot;&gt;&lt;/a&gt;继续刷！&lt;/h2&gt;&lt;h3 id=&quot;若用一个大小为-6-的数组来实现循环队列，且当-rear-和-front-的值分别为-0-和-3-。当从队列中删除</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6-26做题笔记1</title>
    <link href="http://quruipeng666.github.io/2024/06/26/6-26%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/"/>
    <id>http://quruipeng666.github.io/2024/06/26/6-26%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/</id>
    <published>2024-06-26T03:56:56.000Z</published>
    <updated>2024-06-26T08:41:48.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新的一天，新挑战"><a href="#新的一天，新挑战" class="headerlink" title="新的一天，新挑战"></a>新的一天，新挑战</h2><h3 id="设二维数组A-m-n-，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc-a-0-0-求按行优先顺序存放的数组元素a-i-j-0-≤i≤m-1-0≤j≤n-1-的存储地址为"><a href="#设二维数组A-m-n-，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc-a-0-0-求按行优先顺序存放的数组元素a-i-j-0-≤i≤m-1-0≤j≤n-1-的存储地址为" class="headerlink" title="设二维数组A[m][n]，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc(a[0][0]),求按行优先顺序存放的数组元素a[i][j](0 ≤i≤m-1,0≤j≤n-1 )的存储地址为"></a>设二维数组A[m][n]，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc(a[0][0]),求按行优先顺序存放的数组元素a[i][j](0 ≤i≤m-1,0≤j≤n-1 )的存储地址为</h3><p>Loc(a[0][0])+(i乘n+j)乘k</p><p>重点：下标从0开始，不用减。下标从1开始时，i和j都需要-1。先计算偏移量，行号i乘每行个数（总列）n，再加上列号j，总体乘字节k，最后再加上基地址。</p><h3 id="用数组-M-0-N-1-用来表示一个循环队列，-FRONT-指向队头元素，REAR-指向队尾元素的后一个位置，则当前队列中的元素个数是几个？（注：队列总的元素数不会超过队列大小）"><a href="#用数组-M-0-N-1-用来表示一个循环队列，-FRONT-指向队头元素，REAR-指向队尾元素的后一个位置，则当前队列中的元素个数是几个？（注：队列总的元素数不会超过队列大小）" class="headerlink" title="用数组 M[0..N-1] 用来表示一个循环队列， FRONT 指向队头元素，REAR 指向队尾元素的后一个位置，则当前队列中的元素个数是几个？（注：队列总的元素数不会超过队列大小）"></a>用数组 M[0..N-1] 用来表示一个循环队列， FRONT 指向队头元素，REAR 指向队尾元素的后一个位置，则当前队列中的元素个数是几个？（注：队列总的元素数不会超过队列大小）</h3><p>(rear-front+n)%n</p><p>重点：队列中rear指向为下一个地址，rear-front&#x3D;已经存入的个数 。<br>由题意知队列为循环队列，rear的序号可能就比front序号小，所以需要+n再%n。</p><h3 id="选项代码中能正确操作数组元素的是"><a href="#选项代码中能正确操作数组元素的是" class="headerlink" title="选项代码中能正确操作数组元素的是()"></a>选项代码中能正确操作数组元素的是()</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> a[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//访问二维数组a的值</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//选项代码</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>(</em>(a+i)+j)&#x3D;1</p><p>*(a[i]+j)&#x3D;1</p><p>别漏选。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新的一天，新挑战&quot;&gt;&lt;a href=&quot;#新的一天，新挑战&quot; class=&quot;headerlink&quot; title=&quot;新的一天，新挑战&quot;&gt;&lt;/a&gt;新的一天，新挑战&lt;/h2&gt;&lt;h3 id=&quot;设二维数组A-m-n-，每个数组元素占用k个字节，第一个数组元素的存储地址是Loc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6-25做题笔记2</title>
    <link href="http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/"/>
    <id>http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B02/</id>
    <published>2024-06-25T14:29:15.000Z</published>
    <updated>2024-06-25T14:59:34.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这次的题目有些经典"><a href="#这次的题目有些经典" class="headerlink" title="这次的题目有些经典"></a>这次的题目有些经典</h2><h3 id="若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1-n-全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）"><a href="#若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1-n-全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）" class="headerlink" title="若数组S[1..n]作为两个栈S1和S2的存储空间，对任何一个栈，只有当[1..n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）"></a>若数组S[1..n]作为两个栈S1和S2的存储空间，对任何一个栈，只有当[1..n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是（）</h3><p>S1的栈底位置为1，S2的栈底位置为n</p><p>重点：注意数组下标从1开始，栈S1的栈底位置在1，随着元素入栈，朝数组索引增加方向增加。栈S2的栈底位置在n，随元素入栈，朝数组索引减少方向增加。按照这样的方案，只有当数组S全满时才不能进行进栈操作，此时两个栈的指针设想均在数组索引最中间位置。</p><h3 id="假设有60行70列的二维数组-a-1-…60-1…70-以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素-a-32-58-的存储地址为"><a href="#假设有60行70列的二维数组-a-1-…60-1…70-以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素-a-32-58-的存储地址为" class="headerlink" title="假设有60行70列的二维数组 a[1 …60, 1…70 ] 以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素 a[ 32,58 ] 的存储地址为"></a>假设有60行70列的二维数组 a[1 …60, 1…70 ] 以列序为主序顺序存储，其基地址为10000，每个元素占2个存储单元，那么第32行第58列的元素 a[ 32,58 ] 的存储地址为</h3><p>注意：题目是说按列存储，不是按行存储！！存储第32行第58列元素之前，一共存储的元素个数为：57乘60+31&#x3D;3451，需要的存储单元数为3451乘2&#x3D;6902，又因为基地址为10000，故存储完第31行第58列元素位置为16901，所以存储第32行第58列元素地址为16902（开始）。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;这次的题目有些经典&quot;&gt;&lt;a href=&quot;#这次的题目有些经典&quot; class=&quot;headerlink&quot; title=&quot;这次的题目有些经典&quot;&gt;&lt;/a&gt;这次的题目有些经典&lt;/h2&gt;&lt;h3 id=&quot;若数组S-1-n-作为两个栈S1和S2的存储空间，对任何一个栈，只有当-1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6.25做题笔记1</title>
    <link href="http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/"/>
    <id>http://quruipeng666.github.io/2024/06/25/6-25%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B01/</id>
    <published>2024-06-25T13:38:43.000Z</published>
    <updated>2024-06-25T13:56:53.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录"><a href="#大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录" class="headerlink" title="大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录"></a>大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录</h2><h3 id="在一个长度为n的顺序表中删除第i个元素，要移动-个元素。如果要在第i个元素前插入一个元素，要后移-个元素。"><a href="#在一个长度为n的顺序表中删除第i个元素，要移动-个元素。如果要在第i个元素前插入一个元素，要后移-个元素。" class="headerlink" title="在一个长度为n的顺序表中删除第i个元素，要移动_______个元素。如果要在第i个元素前插入一个元素，要后移_________个元素。"></a>在一个长度为n的顺序表中删除第i个元素，要移动_______个元素。如果要在第i个元素前插入一个元素，要后移_________个元素。</h3><p>删除第i个元素，要移动后面   n-i   个元素。在    第i个元素之前    插入，要移动包括    i在内的n-i+1    个元素。</p><p>重点    在第i个之前插，移动要包括那个i元素，则为n-i+1。</p><h3 id="在C-中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是-。"><a href="#在C-中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是-。" class="headerlink" title="在C++中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是( )。"></a>在C++中，以下定义和初始化的两数组a1和a2，那么下列说法正确的是( )。</h3><p>char a1[]&#x3D; “program”;<br>char a2[]&#x3D;{‘p’,’r’,’o’,’g’,’r’,’a’,’m’}</p><p>重点    a1中存储的是字符串，因此在末尾存在字符’\0’。a2中没这个字符，故sizeof(a1)&#x3D;8，sizeof(a2)&#x3D;7，a1存储单元数目多。</p><h3 id="采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？"><a href="#采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？" class="headerlink" title="采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？"></a>采用压缩存储之后，下三角矩阵的存储空间可以节约一半，这样的说法正确吗？</h3><p>重点    不正确。假设2乘2的下三角矩阵，还有123三个元素，只是少了一个元素，没有达到节约一半的空间。</p><h3 id="在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）"><a href="#在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）" class="headerlink" title="在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）"></a>在程序设计中，要对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是（行优先快）</h3><p>如果数组很大的话应该是行优先快，因为数组在内存中是按行优先存储的，在虚存环境下，如果整个数组没有在内存中的话可以比列优先减少内存换进换出的次数。就算整个数组都在内存中，列优先访问a[i][j]还得计算一次乘法，行优先只需加一就可以了，这个可以忽略</p><p>分析:若在内存中,则数据可以”随机存取”,但内存数据被读取或写入时,所需要的时间与这段信息所在的位置无关.但是在读取和写入磁盘时,其所需要的时间与位置就会有关系.因为在BASIC,PASCAL和C&#x2F;C++语言中,数组的存放是按照行优先来存放的,按行号第一行第二行…以此类推.本体关键是考察内存抖动的问题,如果按列访问则需要跳过一大串内存地址,这样可能需求的内存地址不在当前页中则需要进行页置换,这样便需要硬盘IO,减低速度. </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录&quot;&gt;&lt;a href=&quot;#大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续录&quot; class=&quot;headerlink&quot; title=&quot;大学生毕业后开始找工作，始刷牛客，留此记录，后续刷题也会持续</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0512-1</title>
    <link href="http://quruipeng666.github.io/2024/05/12/%E7%AC%94%E8%AE%B00512-1/"/>
    <id>http://quruipeng666.github.io/2024/05/12/%E7%AC%94%E8%AE%B00512-1/</id>
    <published>2024-05-12T13:03:46.000Z</published>
    <updated>2024-05-12T13:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现Player基本移动"><a href="#实现Player基本移动" class="headerlink" title="实现Player基本移动"></a>实现Player基本移动</h2><h3 id="添加必要组件"><a href="#添加必要组件" class="headerlink" title="添加必要组件"></a>添加必要组件</h3><p>Box Collider 2D设置碰撞体，设置到脚下很小的一部分碰撞体</p><p>Rigidbody 2D中的Gravity Scale改为0</p><h3 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h3><p>创建Assets–&gt;Scripts–&gt;Player处的文件，添加Player脚本绑定到Player上</p><h3 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h3><p>思路：x，y轴的输入存到一个Vector2变量里，给到Rigidbody2D，需要float型的speed，x方向输入，y方向输入这些参数，以及一个Vector2作为移动输入变量</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监测输入函数，在Update中要调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayerInput</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if(inputY == 0)，只能横向，竖向这样走（不允许斜着走）</span></span><br><span class="line">        inputX = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="comment">//if(inputX == 0)</span></span><br><span class="line">        inputY = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//都有输入，斜方向移动</span></span><br><span class="line">        <span class="keyword">if</span>(inputX != <span class="number">0</span> &amp;&amp; inputY != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inputX = inputX * <span class="number">0.6f</span>;</span><br><span class="line">            inputY = inputY * <span class="number">0.6f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走路状态速度</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.LeftShift))</span><br><span class="line">        &#123;</span><br><span class="line">            inputX = inputX * <span class="number">0.5f</span>;</span><br><span class="line">            inputY = inputY * <span class="number">0.5f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        movementInput = <span class="keyword">new</span> Vector2(inputX, inputY);</span><br><span class="line"></span><br><span class="line">        isMoving = movementInput != Vector2.zero;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//移动函数，用到了刚体（物理），要在FixUpdate中调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Movement</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//2D横板通常用AddForce添加力，纵向的俯视角的用下边的MovePosition移动坐标的位置</span></span><br><span class="line"><span class="comment">//方法就是将它现有的坐标+movementInput这个方向性的坐标再乘速度就能实现俯视角移动</span></span><br><span class="line">        rb.MovePosition(rb.position + movementInput * speed * Time.deltaTime);</span><br><span class="line"><span class="comment">//乘Time.deltaTime为了修正在不同设备上的，不同帧数下的统一的运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现Player基本移动&quot;&gt;&lt;a href=&quot;#实现Player基本移动&quot; class=&quot;headerlink&quot; title=&quot;实现Player基本移动&quot;&gt;&lt;/a&gt;实现Player基本移动&lt;/h2&gt;&lt;h3 id=&quot;添加必要组件&quot;&gt;&lt;a href=&quot;#添加必要组件&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0511-3</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-3/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-3/</id>
    <published>2024-05-11T12:21:29.000Z</published>
    <updated>2024-05-11T12:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Player"><a href="#Player" class="headerlink" title="Player"></a>Player</h2><h3 id="创建Player"><a href="#创建Player" class="headerlink" title="创建Player"></a>创建Player</h3><p>创建Player空的父物体，设置Sorting Group，里边可以设置Sorting Layer为Instance（父及子物体看作是一个整体进行渲染），在Hierarchy中出现在下方的物体会遮盖上方物体，子物体从上往下排序：Shadow，Body，Hair，Arm</p><p>Sprite Renderer组件中的Sprite Sort Point图片渲染参考点，希望按照脚底的中心来进行排序，所以选Pivot</p><p>Sorting Layer设置对应的图层（Instance）和序，Order in Layer序号越大渲染表现越能遮盖</p><h3 id="俯视角需做小修改"><a href="#俯视角需做小修改" class="headerlink" title="俯视角需做小修改"></a>俯视角需做小修改</h3><p>随便拖个草丛进场景，在Player上下拖动并没有在上侧去到Player后方，按照Z轴方向渲染，数值越小离摄像机越近，反之越远，所以出现这种叠层关系</p><p>Editor–&gt;Project Settings–&gt;Graphics里的Transparency Sort Mode 改成Custom Axis，Y改1，Z改0</p><h3 id="锚点位置设置在底部中心"><a href="#锚点位置设置在底部中心" class="headerlink" title="锚点位置设置在底部中心"></a>锚点位置设置在底部中心</h3><p>是为了处理俯视角的物体遮罩关系</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//未完待续</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Player&quot;&gt;&lt;a href=&quot;#Player&quot; class=&quot;headerlink&quot; title=&quot;Player&quot;&gt;&lt;/a&gt;Player&lt;/h2&gt;&lt;h3 id=&quot;创建Player&quot;&gt;&lt;a href=&quot;#创建Player&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记0511-2</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-2/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E7%AC%94%E8%AE%B00511-2/</id>
    <published>2024-05-11T09:50:01.000Z</published>
    <updated>2024-05-11T10:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模拟经营项目"><a href="#模拟经营项目" class="headerlink" title="模拟经营项目"></a>模拟经营项目</h2><h3 id="导入素材"><a href="#导入素材" class="headerlink" title="导入素材"></a>导入素材</h3><p>在导入的素材里的Art文件夹里，例如Maps里文件名后加@20，意思是瓦片地图可以被切割的，像素单位是20，也就是一个格子里有20个像素</p><p>另外是正常的图片，还有一种是家具，是多图片构成的图片素材，切割的时候使用自动切割，单独去使用里边的图片</p><h3 id="图片设置方式"><a href="#图片设置方式" class="headerlink" title="图片设置方式"></a>图片设置方式</h3><p>以地图为例，选中它，再将Sprite Mode改成Multiple，也就是多图片构成的，Pixels Per Unit设置为20，Filter Mode改成Point(no filter)</p><p>Compression改成None，这样会适应我们要做的像素游戏。Max Size尽量不要超过2048，我们的图片是640×460，那么1024就足够了，完成后点击Apply</p><p>如何将这种图片设置方式定为预设，直接应用就行了呢？添加预设的方法是右上角问号旁边的设置按钮，点击就是选择一个预设，可以将当前的预制保存下Save，找到个文件夹设置叫Slice20，再多选要设置的图片文件，设置里选Slice20再点Apply</p><h3 id="切割图片成瓦片"><a href="#切割图片成瓦片" class="headerlink" title="切割图片成瓦片"></a>切割图片成瓦片</h3><p>点击Sprite Editor–&gt;Slice，Type选Grid By Cell Size（按照尺寸)，项目是按照20的瓦片，Pixel Size的X,Y都为20，锚点位置Pivot保持在Center（图片中心）就可以了</p><p>下边有个模式Method，里边的Smart会切割并保留我们仅有图片像素的位置，那么空白的位置将不被保留，不像以前即使你没有画任何的像素在空格的位置，它也会切割一个瓦片，性能有很大的提升</p><p>另外Smart后期对当前这个图片做额外的修改，也可以用Smart将新增的图片直接添加进去，不会破坏原有的结构，所以通常来讲都用Smart，点击Slice切割，再点Apply，那么一张图片就切好了，跟预想的一样，空白的位置并没有切割出瓦片</p><p>Player文件夹里是分各个部分的，拿工具，头，手，身体，是按照它们的动画来进行分类的，这么做的目的是可以利用只简单切换手臂并保留身体和头发的动画就实现比如跑步，举着东西跑步两种动画的切换，另外，这样分割的好处就是如果以后修改这套素材，例如人物原始的图片资源素材，如果修改了服装，样式的话，你也可以将它导入这种序列帧的动画，然后实现换装的效果，所以将它都分开了</p><p>首先同样应用在Slice20这个Preset，点击Apply后再点Sprite Editor，我们所有人物的动画都是8帧的，所以切割的时候按照Grid By Cell Count来切，Column&amp;Row分别为8,1,锚点Pivot要选在Bottom,Method选为Smart点击Slice切割</p><p>选中一个图片后，锚点是在脚下，因为俯视角游戏，希望按照y轴来进行渲染，进行图层的排序，这样的话会有很明显的遮挡的效果</p><p>家具图片，在Sprite Editor里Type使用Automatic自动切割，Pivot锚点也是底部Bottom，然后选Smart，再点Slice切割，最后点Apply</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未完待续</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模拟经营项目&quot;&gt;&lt;a href=&quot;#模拟经营项目&quot; class=&quot;headerlink&quot; title=&quot;模拟经营项目&quot;&gt;&lt;/a&gt;模拟经营项目&lt;/h2&gt;&lt;h3 id=&quot;导入素材&quot;&gt;&lt;a href=&quot;#导入素材&quot; class=&quot;headerlink&quot; title=&quot;导</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>模拟经营项目的笔记0511</title>
    <link href="http://quruipeng666.github.io/2024/05/11/%E6%A8%A1%E6%8B%9F%E7%BB%8F%E8%90%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AC%94%E8%AE%B00511/"/>
    <id>http://quruipeng666.github.io/2024/05/11/%E6%A8%A1%E6%8B%9F%E7%BB%8F%E8%90%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AC%94%E8%AE%B00511/</id>
    <published>2024-05-11T09:08:35.000Z</published>
    <updated>2024-05-11T09:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><p>本项目要求Unity引擎 编辑器版本 至少在2021.2.10f1c1以上，创建项目的时候要选中此编辑器版本才可生效</p><p>会使用到2D(URP)模板，但建议从2D核心模板开始创建项目，这样还可以学习将当前2D项目升级到通用渲染管线URP</p><h3 id="Unity2021-2-新版界面介绍（工具栏使用"><a href="#Unity2021-2-新版界面介绍（工具栏使用" class="headerlink" title="Unity2021.2 新版界面介绍（工具栏使用"></a>Unity2021.2 新版界面介绍（工具栏使用</h3><p>使用2021.2.10f1c1这样相对来说较新的版本，打开后映入眼帘的是工具栏的样式和位置，那些控制移动的图标(快捷键QWERT,可以直接隐藏，选择Scene窗口再按下空格键弹出小窗口，在里边可以选择显示哪些组件功能例如我不希望Tools显示，点击眼睛关掉即可)，原先应该在工具栏最左侧的位置，现在变成了活动可移动的窗口，拖动也可让它重回原先的位置</p><p>其中的一个按钮展开可以选择图片中心点为移动点或图片锚点为移动点，另一按钮展开为全局的移动旋转或局部的移动旋转可供显示切换</p><p>Scene场景打开灯光显示，下拉菜单打开后处理，天空盒，雾，粒子系统等等，Scene场景摄像机，网格的显示</p><p>Search功能可以搜索，例如我可以在场景当中搜索我想要的关键字，例如我调用了哪个Prefab哪个文件</p><h3 id="Package-Manager（包管理"><a href="#Package-Manager（包管理" class="headerlink" title="Package Manager（包管理"></a>Package Manager（包管理</h3><p>Window–&gt;Package Manager，打开窗口后选择Packages:In Project，可以看到当前项目中以及加载好的组件</p><p>2021.2或以上版本会出现Features分类，里边会包括目前已经内置安装好的功能，我们对里边的2D Tilemap Extras插件不陌生，里边包括规则的瓦片，动态的瓦片这些，Unity已经正式推出并包含在2D主题包当中了</p><p>可以看到有很多上箭头，我们可以选择需要的将它升级，选择不需要的将它Remove移除</p><p>没使用Plastic SCM进行版本管理，可以直接将Version Control移除</p><p>没使用可视化编程，将Visual Scripting移除，这样也可以将包体减小，加载代码快一些</p><p>如果用的Visual Studio最新版编写代码，将Visual Studio Editor升到最新，Rider同理</p><p>Timeline，Test Framework都是需要的，直接更新到最新（需要预览版本preview可以点齿轮Advanced Project Settings</p><h3 id="导入素材，小工具："><a href="#导入素材，小工具：" class="headerlink" title="导入素材，小工具："></a>导入素材，小工具：</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">接下篇</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建新项目&quot;&gt;&lt;a href=&quot;#创建新项目&quot; class=&quot;headerlink&quot; title=&quot;创建新项目&quot;&gt;&lt;/a&gt;创建新项目&lt;/h2&gt;&lt;p&gt;本项目要求Unity引擎 编辑器版本 至少在2021.2.10f1c1以上，创建项目的时候要选中此编辑器版本才可生效</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第一章.数据结构绪论一一《大话数据结构》</title>
    <link href="http://quruipeng666.github.io/2024/03/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    <id>http://quruipeng666.github.io/2024/03/21/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E4%B8%80%E4%B8%80%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/</id>
    <published>2024-03-21T08:35:16.000Z</published>
    <updated>2024-06-27T04:41:36.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h2><p>此为《大话数据结构》书的第一章，数据结构绪论。鄙人正在学习此书中…特此留笔记录</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><h3 id="为什么要学数据结构？"><a href="#为什么要学数据结构？" class="headerlink" title="为什么要学数据结构？"></a>为什么要学数据结构？</h3><p>更好地去感受编程之美</p><h3 id="数据结构研究什么？"><a href="#数据结构研究什么？" class="headerlink" title="数据结构研究什么？"></a>数据结构研究什么？</h3><p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科</p><h3 id="程序设计是什么？"><a href="#程序设计是什么？" class="headerlink" title="程序设计是什么？"></a>程序设计是什么？</h3><p>程序设计&#x3D;数据结构+算法</p><h3 id="数据结构能帮助到程序设计，从而解决问题？"><a href="#数据结构能帮助到程序设计，从而解决问题？" class="headerlink" title="数据结构能帮助到程序设计，从而解决问题？"></a>数据结构能帮助到程序设计，从而解决问题？</h3><p>程序设计的实质是对确定的问题选择一种好的结构，加上设计一种好的算法</p><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>所谓”巧妇难为无米之炊”，计算机再强大，也得有“米”下锅才能干活，否则就是板砖。这个“米”就是数据。</p><p>数据，是描述客观事物的符号，是计算机中可操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</p><p>数据不仅仅包括整型，实型等数值类型，还包括字符及声音，图像，视频等非数值类型</p><p>数据其实就是符号，符号，必须具备两个前提：1.可以输入到计算机中  2.能被计算机程序处理</p><p>对于整型，实型等数值类型，可以进行数值运算</p><p>对于字符数据类型，就需要进行非数值的处理。而声音，图像，视频等其实是可以通过编码的手段变成字符数据来处理的</p><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p>数据元素，是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录</p><p>在人类中，人是数据元素。畜类中，牛，马，羊，鸡，猪，狗等动物是畜类的数据元素</p><h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><p>一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位</p><p>人这个数据元素，可以有眼，耳，鼻，嘴，手，脚数据项，也可以有姓名，年龄，性别，地址，电话等数据项。具体有哪些数据项，视系统决定。</p><p>数据项是数据的最小单位，但真正讨论电影时，讨论的是电影里的角色这样的数据元素，所以数据元素才是数据结构中建立数据模型的着眼点。</p><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>数据对象，是性质相同的数据元素的集合，是数据的子集</p><p>性质相同怎么理解，人都有姓名，生日，性别等相同的数据项</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>结构，简单理解就是关系，比如分子结构，是说组成分子的原子之间的排列方式。</p><p>严格点说，结构是指各个组成部分相互搭配和排列的方式。</p><p>在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构</p><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><p>为编写一个“好”的程序，必须分析待处理对象的特性及各处理对象之间存在的关系</p><h2 id="按照视点的不同，分为逻辑结构和物理结构"><a href="#按照视点的不同，分为逻辑结构和物理结构" class="headerlink" title="按照视点的不同，分为逻辑结构和物理结构"></a>按照视点的不同，分为逻辑结构和物理结构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构，是指数据对象中数据元素之间的相互关系</p><p>逻辑结构分为四种：</p><p>1.集合结构</p><p>集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。类似数学中的集合</p><p>2.线性结构</p><p>线性结构中的数据元素之间是一对一的关系。</p><hr><p>1-2-3-4-5**<br>**********|**<br>********<strong>6</strong><br>**********|**<br>***<strong>9-8-7</strong></p><hr><p>3.树形结构</p><p>树形结构中的数据元素之间存在一种一对多的层次关系</p><hr><p><em><strong><strong><strong><strong><strong>A</strong></strong></strong></strong></strong></em>**</p><hr><p><em><strong><em><strong>B</strong></em>C</strong></em>D*********</p><hr><p><strong>E****F</strong>G<em><strong><em>H</em>I</strong>J**</em></p><hr><p>4.图形结构</p><p>图形结构的数据元素是多对多的关系</p><p>———————————————————————<br>|      |    1  |    2  |   3  |   4  |   5  |   6  |   7  |   8  |   9     |<br>|——————————————————————|<br>| 1   |        |   √  |   √  |       |       |       |       |       |          |<br>| 2   |    √  |       |       |    √ |   √  |       |      |    √ |          |<br>| 3   |    √  |       |       |       |    √  |  √  |      |        |         |<br>| 4   |        |   √  |       |       |        |       |      |    √ |   √    |<br>| 5   |        |   √  |   √  |       |        |       |  √  |       |   √    |<br>| 6   |        |       |   √  |        |       |       |  √  |       |   √    |<br>| 7   |        |       |        |       |   √  |  √   |      |       |   √    |<br>| 8   |        |   √  |        |   √ |        |       |      |       |    √   |<br>| 9   |        |       |        |   √  |   √  |  √   |  √  |   √ |         |<br>———————————————————————</p><p>我们再用示意图表示数据的逻辑结构时，要注意两点：</p><p>1.将每一个数据元素看作一个结点，用圆圈表示</p><p>2.元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示</p><p>逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>物理结构，也叫存储结构。是指数据的逻辑结构在计算机中的存储形式。</p><p>数据的存储结构应正确地反映数据元素之间的逻辑关系</p><p>数据元素的存储结构形式有两种：顺序存储和链式存储</p><p>1.顺序存储结构</p><p>顺序存储结构，是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</p><p>都按顺序排好，每个占一小段空间。数组就是这样的顺序存储结构。当建立一个9个整型数据的数组时，计算机就在内存中找了空地，按照一个整形所占位置大小乘9，开辟一段连续的空间，第一个数组数据第一个位置，第二个数据第二个位置，顺序依次排</p><p>2.链式存储结构</p><p>面对时常要变化的结构，顺序存储并不科学，因为总有插入，总有离开</p><p>链式存储结构，是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的</p><p>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，通过地址就能找到相关联数据元素的位置</p><h2 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h2><p>逻辑结构是面向问题的，物理结构是面向计算机的，其基本目标是将数据及其逻辑关系存储到计算机的内存中</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型，是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</p><p>在C语言中，按照取值的不同，数据类型分为两类：</p><p>1.原子类型：不可以再分解的基本类型，包括整型，实型，字符型</p><p>2.结构类型：由若干个类型组合而成，是可以再分解的。比如，整型数组是由若干整型数据组成的</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象，是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息</p><h3 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>抽象数据类型，是指一个数学模型及定义在该模型上的一组操作</p><p>“抽象”的意义在于数据类型的数学抽象特性</p><p>一个抽象数据类型定义了，一个数据对象，数据对象中各数据元素之间的关系及对数据元素的操作</p><p>事实上，抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p><h3 id="描述抽象数据类型的标准格式"><a href="#描述抽象数据类型的标准格式" class="headerlink" title="描述抽象数据类型的标准格式"></a>描述抽象数据类型的标准格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">操作1</span><br><span class="line">初始条件</span><br><span class="line">操作结果描述</span><br><span class="line">操作2</span><br><span class="line">......</span><br><span class="line">操作n</span><br><span class="line">......</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据，数据对象   有若干个数据元素    有若干个数据项</p><p>数据结构，是相互之间存在一种或多种特定关系的数据元素的集合</p><p>逻辑结构，分为集合结构，线性结构，树形结构，图形结构</p><p>物理结构，分为顺序存储结构，链式存储结构</p><p>抽象数据类型及其描述方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构绪论&quot;&gt;&lt;a href=&quot;#数据结构绪论&quot; class=&quot;headerlink&quot; title=&quot;数据结构绪论&quot;&gt;&lt;/a&gt;数据结构绪论&lt;/h2&gt;&lt;p&gt;此为《大话数据结构》书的第一章，数据结构绪论。鄙人正在学习此书中…特此留笔记录&lt;/p&gt;
&lt;h3 id=&quot;数据</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实现队列</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2024-03-20T13:47:51.000Z</published>
    <updated>2024-03-20T14:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p>主要使用链表实现。这是简单的实现，其他的Clear,Contains等等方法自己实践</p><h3 id="Unity中用VS编译脚本代码实现"><a href="#Unity中用VS编译脚本代码实现" class="headerlink" title="Unity中用VS编译脚本代码实现"></a>Unity中用VS编译脚本代码实现</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 实现队列 : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义队中元素的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">QueueData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队中元素的值</span></span><br><span class="line"><span class="keyword">public</span> QueueData nextItem;</span><br><span class="line"><span class="comment">//队中元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> topData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，一般作用是让参数传进来给这个定义数据结构的变量赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QueueData</span>(<span class="params">QueueData last, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//上一个进的元素（先出队）的下一个元素是当前新进的元素</span></span><br><span class="line">last.nextItem = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QueueData</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义队首元素</span></span><br><span class="line">QueueData top;</span><br><span class="line"><span class="comment">//当前定义的上一个元素</span></span><br><span class="line">QueueData lastData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队Enqueue方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断当前是第一个入队的元素</span></span><br><span class="line"><span class="keyword">if</span>(top == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队首,更新</span></span><br><span class="line">top = <span class="keyword">new</span> QueueData(data);</span><br><span class="line"><span class="comment">//把队首赋值给当前定义的上一个元素</span></span><br><span class="line">lastData = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是第一个入队的元素，不再是队首元素</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每一次新进的元素都会更新lastData</span></span><br><span class="line">lastData = <span class="keyword">new</span> QueueData(top, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队Dequeue方法，注意没参数，返回object型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Dequeue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//队首元素的值，用来出队的</span></span><br><span class="line"><span class="built_in">object</span> rsl = top.topData;</span><br><span class="line"><span class="comment">//入队的地方记录了nextItem，它的下一个item就自然变成了下一个要出的元素，就把它放在队首了</span></span><br><span class="line">top = top.nextItem;</span><br><span class="line"><span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单使用下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义初始化</span></span><br><span class="line">MyQueue mq = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">mq.Enqueue(<span class="number">1</span>);</span><br><span class="line">mq.Enqueue(<span class="number">2</span>);</span><br><span class="line">mq.Enqueue(<span class="number">3</span>);</span><br><span class="line">mq.Enqueue(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队并打印</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//1</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//2</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//3</span></span><br><span class="line">Debug.Log(mq.Dequeue());   <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;队列的实现&quot;&gt;&lt;a href=&quot;#队列的实现&quot; class=&quot;headerlink&quot; title=&quot;队列的实现&quot;&gt;&lt;/a&gt;队列的实现&lt;/h2&gt;&lt;p&gt;主要使用链表实现。这是简单的实现，其他的Clear,Contains等等方法自己实践&lt;/p&gt;
&lt;h3 id=&quot;Uni</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>实现堆栈</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%88/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%88/</id>
    <published>2024-03-20T13:24:12.000Z</published>
    <updated>2024-03-20T13:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆栈的实现"><a href="#堆栈的实现" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h2><h3 id="Unity中用VS编译脚本代码实现"><a href="#Unity中用VS编译脚本代码实现" class="headerlink" title="Unity中用VS编译脚本代码实现"></a>Unity中用VS编译脚本代码实现</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 实现栈 : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义栈中元素的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">StackData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//栈中元素的值</span></span><br><span class="line"><span class="keyword">public</span> StackData nextItem;</span><br><span class="line"><span class="comment">//栈中元素类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">object</span> topData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，一般作用是让参数传进来给这个定义数据结构的变量赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StackData</span>(<span class="params">StackData next, <span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.nextItem = next;</span><br><span class="line"><span class="keyword">this</span>.topData = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个栈顶元素</span></span><br><span class="line">StackData top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈Push方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先生成这个栈中元素，栈顶元素的更新</span></span><br><span class="line">top = <span class="keyword">new</span> StackData(top, Data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈Pop方法，注意没参数，返回object型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Pop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//栈顶元素的值</span></span><br><span class="line"><span class="built_in">object</span> rsl = top.topData;</span><br><span class="line">top = top.nextItem;</span><br><span class="line"><span class="keyword">return</span> rsl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单使用下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义初始化</span></span><br><span class="line">MyStack ms = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">ms.Push(<span class="number">1</span>);</span><br><span class="line">ms.Push(<span class="number">2</span>);</span><br><span class="line">ms.Push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈并打印</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//3</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//2</span></span><br><span class="line">Debug.Log(ms.Pop());   <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆栈的实现&quot;&gt;&lt;a href=&quot;#堆栈的实现&quot; class=&quot;headerlink&quot; title=&quot;堆栈的实现&quot;&gt;&lt;/a&gt;堆栈的实现&lt;/h2&gt;&lt;h3 id=&quot;Unity中用VS编译脚本代码实现&quot;&gt;&lt;a href=&quot;#Unity中用VS编译脚本代码实现&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>队列的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T13:06:57.000Z</published>
    <updated>2024-03-20T13:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出，后进后出。（队列的队指的是排队，先来的先走，后来的后走）</p><p>需要引用using System.Collections;（object型）<br>需要引用using System.Collections.Generic;（泛型）</p><h3 id="Queue的定义"><a href="#Queue的定义" class="headerlink" title="Queue的定义"></a>Queue的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//object型的队列定义及初始化，object型需要装箱拆箱类型转换，会有一定的效率损失</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型队列定义</span></span><br><span class="line">Queue&lt;<span class="built_in">int</span>&gt; queue2 = <span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="comment">//往队列中加元素，入队操作</span></span><br><span class="line">queue.EnQueue(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">queue2.EnQueue(<span class="number">1</span>);</span><br><span class="line">queue2.EnQueue(<span class="number">2</span>);</span><br><span class="line">queue2.EnQueue(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队首元素先离，队列中排最前边（最先进来的）的那个元素先出了，离队操作，此处1先离开</span></span><br><span class="line"><span class="built_in">int</span> v = queue2.Dequeue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">queue2.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断入参的值v是否在队列中</span></span><br><span class="line">queue2.Contains(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//目前队列有几个元素queue2.Count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> w <span class="keyword">in</span> queue2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印w</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>对象池，ObjectPool，一开始会预先加载一定的对象在队列里，用的时候出队，用完再入队。这样是一个循环使用的状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;先进先出，后进后出。（队列的队指的是排队，先来的先走，后来的后走）&lt;/p&gt;
&lt;p&gt;需要引用using System.Collections;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>堆栈的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E5%A0%86%E6%A0%88%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E5%A0%86%E6%A0%88%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T12:47:23.000Z</published>
    <updated>2024-03-20T13:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>一种数据容器，也可以叫对象集合。Stack，先进后出，后进先出的对象集合。跟队列的先进先出，后进后出相反</p><h3 id="Stack的定义"><a href="#Stack的定义" class="headerlink" title="Stack的定义"></a>Stack的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">Stack st1 = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//压进元素，入栈操作，在栈的底部，参数为object型，类型不安全</span></span><br><span class="line">st1.Push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的倒二位，此时在栈的顶部，理解为往杯子里放海绵垫，比如拿出海绵垫时，只能先拿最上面的（后进先出）</span></span><br><span class="line">st1.Push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">st1.Push(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">st1.Push(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出元素，出栈操作，出来类型是object型，强转为初始定义的string型，再用v接收，此处v的值是d</span></span><br><span class="line"><span class="built_in">string</span> v = (<span class="built_in">string</span>)st1.Pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//st1.Count表示目前栈中元素的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到当前在栈顶元素的值，并不出栈，不执行Pop操作</span></span><br><span class="line">v = (<span class="built_in">string</span>)st1.Peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">st1.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前入参v的值是否存在于当前栈中</span></span><br><span class="line">st1.Contains(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> w <span class="keyword">in</span> st1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印w</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆栈&quot;&gt;&lt;a href=&quot;#堆栈&quot; class=&quot;headerlink&quot; title=&quot;堆栈&quot;&gt;&lt;/a&gt;堆栈&lt;/h2&gt;&lt;p&gt;一种数据容器，也可以叫对象集合。Stack，先进后出，后进先出的对象集合。跟队列的先进先出，后进后出相反&lt;/p&gt;
&lt;h3 id=&quot;Stack</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链表的学习</title>
    <link href="http://quruipeng666.github.io/2024/03/20/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://quruipeng666.github.io/2024/03/20/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-03-20T11:55:36.000Z</published>
    <updated>2024-03-20T12:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p> C#里的链表有前驱和后驱，严格上说叫双向链表</p><p>需要引用using System.Collections.Generic;</p><h3 id="双向链表的定义"><a href="#双向链表的定义" class="headerlink" title="双向链表的定义"></a>双向链表的定义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化定义,也是泛型</span></span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt; linList = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点变量定义,也int型</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt; node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟List,数组是不一样的，因为它们在内存中是属于一个连续的存储空间，其实List本质底层也是数组。</span></span><br><span class="line"><span class="comment">//像链表，实际上在内存中是离散的，它的空间并不连续，而是通过两个指针，一个指针指向下一个存储位置的地址，另一个指针指向上一个存储位置的地址，链表的链指的就是指针的意思</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加首节点，值是1，前后节点都没有，整个链表里目前只有一个值</span></span><br><span class="line">node = linList.AddFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点的后边添加，一参数为节点，二参为值</span></span><br><span class="line">linList.AddAfter(node,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点的前边添加，node变成现在最新的首节点</span></span><br><span class="line">node = linList.AddBefore(node,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的长度linList.Count,此处是3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空，linList.Clear();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//linList.First.Value为第一个节点当前存的值</span></span><br><span class="line"><span class="comment">//linList.Last.Value为最后一个节点当前存的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处为首节点的前置节点的值node.Previous.Value，node.Previous已经是null了，.Value就会报错</span></span><br><span class="line"><span class="comment">//此处为首节点的下一节点的值node.Next.Value,所以在实际应用时有可能node是最后一个节点，node.Next需要先判断不是null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加到最后一个节点</span></span><br><span class="line">linList.AddLast();</span><br></pre></td></tr></table></figure><h3 id="链表，List，数组。优缺点"><a href="#链表，List，数组。优缺点" class="headerlink" title="链表，List，数组。优缺点"></a>链表，List，数组。优缺点</h3><p>List，数组都是顺序存储，存储空间是连续的，尤其对于List来说，因为数组是不变长度的，List是预先定义了一个较长的数组，在中间添加或移除之后，它会将整个的数组进行位移，比如把索引位为3的值删除掉了，那么索引位为4，5，6直到最后一个都会往前挪一位，那么这样的操作也是比较有消耗的。<br>但对于链表来说，因为本身的存储空间就是离散的，只靠指针连接，那么当删除或插入的时候，仅仅改变的是指针的指向，效率会高于List和数组。<br>但链表在查找的时候，只能通过Next,Previous,First,Last去找到节点，并不能通过索引直接拿到，查找速度只能靠一个一个遍历，而数组，List都可以通过索引位直接拿，查找时间复杂度是O(1)，而对链表来说是O(n)，链表查找的时候效率比较低</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt; C#里的链表有前驱和后驱，严格上说叫双向链表&lt;/p&gt;
&lt;p&gt;需要引用using System.Collections.Generic;&lt;/</summary>
      
    
    
    
    
  </entry>
  
</feed>
